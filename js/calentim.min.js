! function (v, o, r, h) {
    function e(t, e) {
        this.elem = t, this.$elem = v(t), this.options = e, this.metadata = this.$elem.data("plugin-options")
    }
    e.defaults = (e.prototype = {
        public: function () {
            return {
                startDate: moment(),
                endDate: moment(),
                format: "L LT",
                dateSeparator: " - ",
                calendarCount: 2,
                mobileBreakpoint: 760,
                isHotelBooking: !1,
                inline: !1,
                minDate: null,
                maxDate: null,
                showHeader: !0,
                showFooter: !0,
                rangeOrientation: "horizontal",
                verticalRangeWidth: 180,
                showTimePickers: !0,
                showCalendars: !0,
                showButtons: !1,
                hourFormat: 12,
                dontPrefixHours: !1,
                minuteSteps: 1,
                startOnMonday: !1,
                container: "body",
                oneCalendarWidth: 230,
                enableKeyboard: !0,
                showOn: "bottom",
                arrowOn: "left",
                autoAlign: !0,
                locale: moment.locale(),
                singleDate: !1,
                target: null,
                autoCloseOnSelect: !1,
                startEmpty: !1,
                ranges: [{
                    title: "Today",
                    startDate: moment().startOf("day"),
                    endDate: moment().endOf("day")
                }, {
                    title: "3 Days",
                    startDate: moment().startOf("day"),
                    endDate: moment().add(2, "days").endOf("day")
                }, {
                    title: "5 Days",
                    startDate: moment().startOf("day"),
                    endDate: moment().add(4, "days").endOf("day")
                }, {
                    title: "1 Week",
                    startDate: moment().startOf("day"),
                    endDate: moment().add(6, "days").endOf("day")
                }, {
                    title: "Till Next Week",
                    startDate: moment().startOf("day"),
                    endDate: moment().endOf("week").endOf("day")
                }, {
                    title: "Till Next Month",
                    startDate: moment().startOf("day"),
                    endDate: moment().endOf("month").endOf("day")
                }],
                rangeLabel: "Ranges: ",
                cancelLabel: "Cancel",
                applyLabel: "Apply",
                nextMonthIcon: "<i class='fa fa-arrow-right'></i>",
                prevMonthIcon: "<i class='fa fa-arrow-left'></i>",
                rangeIcon: "<i class='fa fa-retweet'></i>",
                headerSeparator: "<i class='fa fa-chevron-right'></i>",
                onbeforeselect: function () {
                    return !0
                },
                onCancel: function () {
                    return !0
                },
                onafterselect: function () {},
                onbeforeshow: function () {},
                onbeforehide: function () {},
                onaftershow: function () {},
                onafterhide: function () {},
                onfirstselect: function () {},
                onrangeselect: function () {},
                onbeforemonthchange: function () {
                    return !0
                },
                onaftermonthchange: function () {},
                onafteryearchange: function () {},
                ondraw: function () {},
                onBeforeInit: function () {},
                onBeforeDestroy: function () {
                    return !0
                },
                ondestroy: function () {},
                validateClick: function () {
                    return !0
                },
                oninit: function () {},
                ontimechange: function () {},
                disableDays: function () {
                    return !1
                },
                limitTimeForDay: function () {
                    return {
                        start: {
                            hour: 0,
                            minute: 0,
                            ampm: null
                        },
                        end: {
                            hour: 23,
                            minute: 59,
                            ampm: null
                        }
                    }
                },
                disabledRanges: [],
                continuous: !1,
                disableOnlyStart: !1,
                disableOnlyEnd: !1,
                minSelectedDays: 0,
                enableMonthSwitcher: !0,
                monthSwitcherFormat: "MMMM",
                enableYearSwitcher: !0,
                enableSwipe: !0,
                numericMonthSelector: !1,
                reverseTimepickerArrows: !1,
                showWeekNumbers: !1,
                hideOutOfRange: !1,
                DOBCalendar: !1,
                isRTL: !1
            }
        },
        private: function () {
            return {
                startSelected: !1,
                currentDate: moment(),
                endSelected: !0,
                hoverDate: null,
                keyboardHoverDate: null,
                headerStartDay: null,
                headerStartDate: null,
                headerStartWeekday: null,
                headerEndDay: null,
                headerEndDate: null,
                headerEndWeekday: null,
                swipeTimeout: null,
                isMobile: !1,
                valElements: ["BUTTON", "OPTION", "INPUT", "LI", "METER", "PROGRESS", "PARAM"],
                dontHideOnce: !1,
                initiator: null,
                initComplete: !1,
                startDateBackup: null,
                firstValueSelected: !1,
                startDateInitial: null,
                endDateInitial: null,
                startScrolling: !1,
                lastScrollDirection: "bottom",
                throttleTimeout: null,
                documentEvent: null,
                delayInputUpdate: !1,
                startTimeBackup: null,
                endTimeBackup: null,
                mouseTimer: !1,
                preventMouseClick: !1,
                lastScrollX: 0,
                lastScrollY: 0,
                isTicking: !1,
                parentScrollEventsAttached: !1,
                rafID: 0,
                disabledDays: {},
                skipTabKeyOnInput: !1
            }
        },
        init: function () {
            return this.config = v.extend({}, this.public(), this.options, this.metadata), this.globals = v.extend({}, this.private()), this.globals.isMobile = this.checkMobile(), v("body").addClass(this.checkTouch() ? "calentim-touch" : "calentim-notouch"), this.config.onBeforeInit(this), this.applyConfig(), this.fetchInputs(), !1 !== this.config.startEmpty && !this.globals.firstValueSelected || (this.globals.currentDate = moment(this.config.startDate)), this.drawUserInterface(), this.addInitialEvents(), this.$elem.data("calentim", this), this.config.oninit(this), this.globals.initComplete = !0, this.globals.lastScrollX = o.scrollX || o.pageXOffset || r.documentElement.scrollLeft, this.globals.lastScrollY = o.scrollY || o.pageYOffset || r.documentElement.scrollTop, v(o).trigger("resize.calentim"), this
        },
        validateDates: function () {
            if (null !== this.config.startDate && null !== this.config.endDate) {
                var t = moment(this.config.startDate, this.config.format).locale(this.config.locale),
                    e = moment(this.config.endDate, this.config.format).locale(this.config.locale),
                    i = moment().locale(this.config.locale);
                !1 === this.config.singleDate ? (t.isValid() && e.isValid() ? t.isBefore(e) ? (this.config.startDate = t.clone(), this.config.endDate = e.clone()) : (this.config.startDate = e.clone(), this.config.endDate = t.clone()) : (this.config.startDate = i.clone(), this.config.endDate = i.clone()), this.config.startDate = this.TimeInsideLimits(this.config.startDate, "start"), this.config.endDate = this.TimeInsideLimits(this.config.endDate, "end")) : (!1 === t.isValid() ? this.config.startDate = i.clone() : this.config.startDate = t.clone(), this.config.startDate = this.TimeInsideLimits(this.config.startDate, "start"));
                var n = null,
                    s = null;
                null !== this.config.minDate && ((n = moment(this.config.minDate, this.config.format).locale(this.config.locale)).isValid() ? this.config.minDate = n.clone() : n = this.config.minDate = null), null !== this.config.maxDate && ((s = moment(this.config.maxDate, this.config.format).locale(this.config.locale)).isValid() ? n ? n.isBefore(s) ? this.config.maxDate = s.clone() : (this.config.minDate = s.clone(), this.config.maxDate = n.clone()) : this.config.maxDate = s.clone() : s = this.config.maxDate = null), n && t && n.isAfter(t, "day") && (this.config.startDate = n.clone()), n && e && n.isAfter(e, "day") && (this.config.endDate = n.clone()), s && t && s.isBefore(t, "day") && (this.config.startDate = s.clone()), null !== s && null !== e && s.isBefore(e, "day") && (this.config.endDate = s.clone()), (!1 === this.checkRangeContinuity() || 1 == this.config.disableOnlyStart && this.isDisabled(this.config.startDate, this.config.isHotelBooking) || !1 === this.config.singleDate && this.config.disableOnlyEnd && this.isDisabled(this.config.endDate, this.config.isHotelBooking) || this.config.startEmpty && 0 == this.globals.firstValueSelected) && this.clearInput()
            }
        },
        applyConfig: function () {
            null === this.config.target && (this.config.target = this.$elem), !0 === this.config.inline && (this.config.DOBCalendar = !1), 1 == this.config.DOBCalendar && (this.config.singleDate = !0), ["startDate", "endDate", "minDate", "maxDate"].forEach(function (t) {
                this.config[t] = this.fixDateTime(this.config[t])
            }, this), this.config.ranges.map(function (t) {
                return t.startDate = this.fixDateTime(t.startDate), t.endDate = this.fixDateTime(t.endDate), t
            }, this), !1 === this.globals.isMobile ? (!0 === this.config.inline ? (this.container = this.$elem.wrapAll("<div class='calentim-container calentim-inline' onclick=''></div>").parent(), this.input = v("<div class='calentim-input'></div>").appendTo(this.container), this.elem.type = "hidden", this.config.showButtons = !1, this.setViewport()) : (this.container = v("<div class='calentim-container calentim-popup' style='display: none;' onclick=''><div class='calentim-box-arrow-top'></div></div>").appendTo(this.config.container), this.input = v("<div class='calentim-input'></div>").appendTo(this.container), this.config.showButtons && (this.globals.delayInputUpdate = !0, this.config.autoCloseOnSelect = !1)), "horizontal" === this.config.rangeOrientation ? this.input.css("width", this.config.calendarCount * this.config.oneCalendarWidth + "px") : this.input.css("width", this.config.calendarCount * this.config.oneCalendarWidth + this.config.verticalRangeWidth + "px")) : (!0 === this.config.inline ? (this.container = this.$elem.wrapAll("<div class='calentim-container-mobile calentim-inline' onclick=''></div>").parent(), this.input = v("<div class='calentim-input'></div>").appendTo(this.container), this.elem.type = "hidden", this.config.showButtons = !1) : (this.container = v("<div class='calentim-container-mobile' onclick=''></div>").appendTo(this.config.container), this.input = v("<div class='calentim-input' style='display: none;'></div>").appendTo(this.container), 0 === v("body > .calentim-overlay").length ? (this.overlay = v("<div class='calentim-overlay' style='display: none'></div>").appendTo("body"), this.overlay.on("click.calentim tap.calentim", function () {
                var t = v("body > .calentim-container-mobile");
                0 < t.length && t.each(function () {
                    "none" != v(this).css("display") && v(this).find(".calentim-cancel").click()
                })
            })) : this.overlay = v("body > .calentim-overlay").first(), this.config.showButtons && (this.config.autoCloseOnSelect = !1), this.config.autoCloseOnSelect || (this.globals.delayInputUpdate = !0)), this.$elem.on("focus", function () {
                v(this).blur()
            })), this.config.isHotelBooking && this.container.addClass("calentim-hotel-style"), this.container.data("calentim", this), this.clearRangeSelection()
        },
        clearRangeSelection: function () {
            for (var t = 0; t < this.config.ranges.length; t++) this.config.ranges[t].selected = !1;
            this.container.find(".calentim-range").each(function () {
                v(this).removeClass("calentim-range-selected")
            })
        },
        fetchInputs: function () {
            var t = null;
            if (t = -1 !== v.inArray(this.config.target.get(0).tagName, this.globals.valElements) ? this.config.target.val() : this.config.target.text(), !1 === this.config.singleDate && 0 < t.indexOf(this.config.dateSeparator) && "" !== t) {
                var e = t.split(this.config.dateSeparator);
                if (2 == e.length && moment(e[0], this.config.format, this.config.locale).isValid() && moment(e[1], this.config.format, this.config.locale).isValid()) {
                    var i = null;
                    this.config.showCalendars && (moment.isMoment(this.config.startDate) ? (i = moment(e[0], this.config.format, this.config.locale), this.config.startDate.year(i.year()).month(i.month()).date(i.date())) : this.config.startDate = moment(e[0], this.config.format, this.config.locale), moment.isMoment(this.config.endDate) ? (i = moment(e[1], this.config.format, this.config.locale), this.config.endDate.year(i.year()).month(i.month()).date(i.date())) : this.config.endDate = moment(e[1], this.config.format, this.config.locale)), this.config.showTimePickers && (moment.isMoment(this.config.startDate) ? (i = moment(e[0], this.config.format, this.config.locale), this.config.startDate.hour(i.hour()).minute(i.minute()).seconds(i.seconds())) : this.config.startDate = moment(e[0], this.config.format, this.config.locale), moment.isMoment(this.config.endDate) ? (i = moment(e[1], this.config.format, this.config.locale), this.config.endDate.hour(i.hour()).minute(i.minute()).seconds(i.seconds())) : this.config.endDate = moment(e[1], this.config.format, this.config.locale)), this.globals.firstValueSelected = !0
                }
            } else if (!0 === this.config.singleDate) {
                var n = t;
                "" !== n && moment(n, this.config.format, this.config.locale).isValid() && (this.config.startDate = moment(n, this.config.format, this.config.locale), this.config.endDate = moment(n, this.config.format, this.config.locale), this.globals.firstValueSelected = !0)
            }
            this.config.startEmpty && !this.globals.firstValueSelected && this.clearInput(), this.validateDates(), this.updateTimePickerDisplay()
        },
        drawUserInterface: function () {
            if (this.drawHeader(), this.calendars = this.input.find(".calentim-calendars").first(), !0 === this.config.showCalendars) {
                var t = this.globals.currentDate.clone().middleOfDay();
                this.globals.disabledDays = {};
                for (var e = 0; e < this.config.calendarCount; e++) this.drawCalendarOfMonth(t), t = t.month(t.month() + 1);
                this.calendars.find(".calentim-calendar").last().addClass("no-border-right"), this.drawArrows()
            } else this.calendars.hide(), this.container.addClass("calentim-hidden-calendar");
            if (this.drawTimePickers(), this.addKeyboardEvents(), this.drawFooter(), this.reDrawCells(), this.globals.initComplete && this.setViewport(), this.config.isRTL && (this.container.css("direction", "rtl"), this.container.addClass("calentim-rtl")), !1 === this.globals.startSelected)
                if (this.globals.initComplete) this.updateInput(!1, !1);
                else {
                    var i = this.globals.delayInputUpdate;
                    this.globals.delayInputUpdate = !1, this.updateInput(!1, !1), this.globals.delayInputUpdate = i
                }
        },
        drawHeader: function () {
            var t = "<div class='calentim-header'><div class='calentim-header-start'><div class='calentim-header-start-day'></div><div class='calentim-header-start-date'></div><div class='calentim-header-start-weekday'></div></div>";
            !1 === this.config.singleDate && (t += "<div class='calentim-header-separator'>" + this.config.headerSeparator + "</div><div class='calentim-header-end'><div class='calentim-header-end-day'></div><div class='calentim-header-end-date'></div><div class='calentim-header-end-weekday'></div></div>"), t += "</div><div class='calentim-calendars' tabindex='0'></div>", this.input.append(t), !1 !== this.config.showHeader && !1 !== this.config.showCalendars || this.input.find(".calentim-header").hide(), this.globals.headerStartDay = this.input.find(".calentim-header-start-day"), this.globals.headerStartDate = this.input.find(".calentim-header-start-date"), this.globals.headerStartWeekday = this.input.find(".calentim-header-start-weekday"), this.globals.headerEndDay = this.input.find(".calentim-header-end-day"), this.globals.headerEndDate = this.input.find(".calentim-header-end-date"), this.globals.headerEndWeekday = this.input.find(".calentim-header-end-weekday"), this.updateHeader()
        },
        updateHeader: function () {
            null !== this.config.startDate ? (this.config.startDate.locale(this.config.locale), this.globals.headerStartDay.text(this.localizeNumbers(this.config.startDate.date())), this.globals.isMobile ? this.globals.headerStartDate.text(this.config.startDate.format("MMM") + " " + this.localizeNumbers(this.config.startDate.year())) : this.globals.headerStartDate.text(this.config.startDate.format("MMMM") + " " + this.localizeNumbers(this.config.startDate.year())), this.globals.headerStartWeekday.text(this.config.startDate.format("dddd"))) : (this.globals.headerStartDay.text(""), this.globals.headerStartDate.text(""), this.globals.headerStartWeekday.text("")), !1 === this.config.singleDate && (null !== this.config.endDate ? (this.config.endDate.locale(this.config.locale), this.globals.headerEndDay.text(this.localizeNumbers(this.config.endDate.date())), this.globals.isMobile ? this.globals.headerEndDate.text(this.config.endDate.format("MMM") + " " + this.localizeNumbers(this.config.endDate.year())) : this.globals.headerEndDate.text(this.config.endDate.format("MMMM") + " " + this.localizeNumbers(this.config.endDate.year())), this.globals.headerEndWeekday.text(this.config.endDate.format("dddd"))) : (this.globals.headerEndDay.text(""), this.globals.headerEndDate.text(""), this.globals.headerEndWeekday.text("")))
        },
        isUpdateable: function () {
            var t = this.globals.delayInputUpdate,
                e = this.config.startEmpty && !this.globals.firstValueSelected;
            return (e = (e = e || !0 === this.config.singleDate && null === this.config.startDate) || !1 === this.config.singleDate && (null === this.config.startDate || !1 === this.globals.startSelected && null === this.config.endDate)) && this.clearInput(), !e && !t
        },
        updateInput: function (t, e) {
            this.isUpdateable() && (this.readTimeFromDisplay(!1), this.config.startDate && this.config.endDate && (this.config.startDate.locale(this.config.locale), this.config.endDate.locale(this.config.locale), -1 !== v.inArray(this.config.target.get(0).tagName, this.globals.valElements) ? !1 === this.config.singleDate ? this.config.target.val(this.config.startDate.format(this.config.format) + this.config.dateSeparator + this.config.endDate.format(this.config.format)) : this.config.target.val(this.config.startDate.format(this.config.format)) : !1 === this.config.singleDate ? this.config.target.text(this.config.startDate.format(this.config.format) + this.config.dateSeparator + this.config.endDate.format(this.config.format)) : this.config.target.text(this.config.startDate.format(this.config.format)), this.globals.initComplete && (e ? this.config.ontimechange(this, this.config.startDate ? this.config.startDate.clone() : null, this.config.endDate ? this.config.endDate.clone() : null) : t && this.config.onafterselect(this, this.config.startDate ? this.config.startDate.clone() : null, this.config.endDate ? this.config.endDate.clone() : null), this.input.trigger("change"))))
        },
        clearInput: function (t) {
            if (-1 !== v.inArray(this.config.target.get(0).tagName, this.globals.valElements) ? (this.config.singleDate, this.config.target.val("")) : (this.config.singleDate, this.config.target.text("")), this.config.startDate = null, this.config.endDate = null, this.globals.startDateInitial = null, this.globals.endDateInitial = null, t ? (this.config.startEmpty = !0, this.globals.firstValueSelected = !1) : 1 == this.config.startEmpty && (this.globals.firstValueSelected = !1), this.globals.initComplete) {
                this.updateHeader();
                var e = void 0 === this.footer ? [] : this.footer.find(".calentim-apply");
                0 < e.length && e.attr("disabled", "disabled")
            }
        },
        drawArrows: function () {
            var t = this.config.hideOutOfRange && this.config.minDate && this.globals.currentDate.clone().add(-1, "month").isBefore(this.config.minDate, "month"),
                e = this.config.hideOutOfRange && this.config.maxDate && this.globals.currentDate.clone().add(this.config.calendarCount, "month").isAfter(this.config.maxDate, "month");
            0 < this.container.find(".calentim-title").length && (this.globals.isMobile ? (t || this.container.find(".calentim-title").prepend("<div class='calentim-prev'>" + this.config.prevMonthIcon + "</div>"), e || this.container.find(".calentim-title").append("<div class='calentim-next'>" + this.config.nextMonthIcon + "</div>")) : (t || this.container.find(".calentim-title").first().prepend("<div class='calentim-prev'>" + this.config.prevMonthIcon + "</div>"), e || this.container.find(".calentim-title").last().append("<div class='calentim-next'>" + this.config.nextMonthIcon + "</div>")))
        },
        drawCalendarOfMonth: function (t) {
            t.locale(this.config.locale);
            var e = moment(t).locale(this.config.locale).startOf("month").startOf("isoweek").middleOfDay(),
                i = e.day();
            1 == i && !1 === this.config.startOnMonday ? (e.subtract(1, "days"), i = 0) : 0 === i && !0 === this.config.startOnMonday && (e.add(1, "days"), i = 1), e.isAfter(moment(t).date(1)) && e.add(-7, "day");
            var n = "<div class='calentim-calendar" + (this.config.showWeekNumbers ? " calentim-calendar-weeknumbers" : "") + "' data-month='" + t.month() + "'>",
                s = 0,
                a = "",
                o = "";
            this.config.enableMonthSwitcher && (a = " class='calentim-month-switch'"), this.config.enableYearSwitcher && (o = " class='calentim-year-switch'"), n += "<div class='calentim-title'><span><b" + a + ">" + t.format("MMMM") + "</b> <span" + o + ">" + this.localizeNumbers(t.year()) + "</span></span></div>", n += "<div class='calentim-days-container'>", this.config.showWeekNumbers && (n += "<div class='calentim-dayofweek'> </div>");
            for (var r = i; r < i + 7; r++) n += "<div class='calentim-dayofweek'>" + moment().day(r % 7).locale(this.config.locale).format("ddd") + "</div>";
            for (var l = e.clone().add(-24, "hours").middleOfDay(), c = l.unix(), h = this.isDisabledOnDraw(l); s < 42;) {
                var d = e.middleOfDay().unix(),
                    m = t.month() == e.month() ? "calentim-day" : "calentim-disabled";
                s % 7 == 0 && this.config.showWeekNumbers && (n += "<div class='calentim-weeknumber'><span>" + e.format("ww") + "</span></div>"), n += "<div class='" + m + "' data-value='" + d + "'><span>" + this.localizeNumbers(e.date()) + "</span></div>", this.isDisabledOnDraw(e) ? (this.globals.disabledDays[d] = 1 == h ? 2 : 1, h = !0, c = d) : (1 == h && null != c && (this.globals.disabledDays[c] = 3), h = !1), e.add(moment.duration({
                    days: 1
                })), s++
            }
            n += "</div>", n += "</div>", this.calendars.append(n)
        },
        drawTimePickers: function () {
            this.input.find(".calentim-timepickers").remove(), this.input.append("<div class='calentim-timepickers'></div>"), this.timepickers = this.input.find(".calentim-timepickers"), this.config.showTimePickers || this.timepickers.hide();
            var t = 0,
                e = 23,
                i = !1;
            12 == this.config.hourFormat && (t = 1, e = 12, i = !0);
            var n = v("<div class='calentim-timepicker calentim-timepicker-start'></div>").appendTo(this.timepickers);
            this.addTimePickerHours(n, t, e), this.addTimePickerHourMinuteSeparator(n), this.addTimePickerMinutes(n, this.config.minuteSteps, 0, 59), i && this.addTimePickerAMPM(n), !1 === this.config.singleDate && (n = v("<div class='calentim-timepicker calentim-timepicker-end'></div>").appendTo(this.timepickers), this.addTimePickerHours(n, t, e), this.addTimePickerHourMinuteSeparator(n), this.addTimePickerMinutes(n, this.config.minuteSteps, 0, 59), i && this.addTimePickerAMPM(n)), this.addTimePickerEvents(), this.updateTimePickerDisplay()
        },
        addTimePickerHours: function (t, e, i) {
            t[0].classList.contains("calentim-timepicker-start");
            var n = v("<div class='calentim-timepicker-hours-wrapper' tabindex='0'></div>").appendTo(t),
                s = v("<div class='calentim-timepicker-hours'></div>").appendTo(n),
                a = "<div class='calentim-hour-selected-prev'> </div>";
            a += "<div class='calentim-hour-selected'>" + ("00" + e).slice(-2) + "</div>", a += "<div class='calentim-hour-selected-next'>" + ("00" + (e + 1)).slice(-2) + "</div>", s.append(a).data({
                value: e,
                min: e,
                max: i,
                step: 1
            }), v("<div class='calentim-timepicker-hour-arrows'><div class='calentim-timepicker-hours-up " + (this.config.reverseTimepickerArrows ? "calentim-direction-down" : "calentim-direction-up") + "'><i class='fa fa-arrow-up'></i></div><div class='calentim-timepicker-hours-down " + (this.config.reverseTimepickerArrows ? "calentim-direction-up" : "calentim-direction-down") + "'><i class='fa fa-arrow-down'></i></div></div>").appendTo(t)
        },
        addTimePickerMinutes: function (t, e, i, n) {
            t[0].classList.contains("calentim-timepicker-start");
            var s = v("<div class='calentim-timepicker-minutes-wrapper' tabindex='0'></div>").appendTo(t);
            v("<div class='calentim-timepicker-minutes'></div>").appendTo(s).append("<div class='calentim-minute-selected-prev'> </div><div class='calentim-minute-selected'>00</div><div class='calentim-minute-selected-next'>01</divided>").data({
                value: i,
                min: i,
                max: n % e != 0 ? n - n % e : n,
                step: e
            }), v("<div class='calentim-timepicker-minute-arrows'><div class='calentim-timepicker-minutes-up " + (this.config.reverseTimepickerArrows ? "calentim-direction-down" : "calentim-direction-up") + "'><i class='fa fa-arrow-up'></i></div><div class='calentim-timepicker-minutes-down " + (this.config.reverseTimepickerArrows ? "calentim-direction-up" : "calentim-direction-down") + "'><i class='fa fa-arrow-down'></i></div></div>").appendTo(t)
        },
        addTimePickerHourMinuteSeparator: function (t) {
            v("<div class='calentim-hour-minute-seperator'>:</div>").appendTo(t)
        },
        addTimePickerAMPM: function (t) {
            t[0].classList.contains("calentim-timepicker-start");
            var e = v("<div class='calentim-timepicker-ampm' tabindex='0'></div>").appendTo(t);
            e.append("<div class='calentim-timepicker-ampm-am'>" + this.localizeAMPM("AM") + "</div>"), e.append("<div class='calentim-timepicker-ampm-pm'>" + this.localizeAMPM("PM") + "</div>")
        },
        addTimePickerEvents: function () {
            function i(t) {
                var e = t.parents(".calentim-container, .calentim-container-mobile").first().data("calentim"),
                    i = t.parents(".calentim-timepicker").attr("class"),
                    n = t.attr("class"),
                    s = 0 <= i.indexOf("calentim-timepicker-start") ? "start" : "end",
                    a = 0 < n.indexOf("timepicker-minutes") ? "minute" : "hour",
                    o = 0 <= n.indexOf("calentim-direction-up") ? "up" : "down";
                if (null !== e.config[s + "Date"]) {
                    var r = "hour" == a ? 1 : e.config.minuteSteps,
                        l = e.config[s + "Date"],
                        c = l.clone().add(!1 === e.config.reverseTimepickerArrows ? "up" == o ? -1 * r : r : "down" == o ? r : -1 * r, a);
                    c.set({
                        date: l.date(),
                        month: l.month(),
                        year: l.year()
                    });
                    var h = e.TimeInsideLimits(c, l);
                    e.config[s + "Date"] = h.clone(), e.updateTimePickerDisplay(), e.updateInput(!1, !0)
                }
            }
            var n = this;
            v(r).off("mousedown.calentim").on("mousedown.calentim", ".calentim-timepicker-minutes-up, .calentim-timepicker-minutes-down, .calentim-timepicker-hours-up, .calentim-timepicker-hours-down", function (t) {
                var e = this;
                n.globals.mouseTimer && clearInterval(n.globals.mouseTimer), i(v(e)), n.globals.mouseTimer = setInterval(function () {
                    i(v(e))
                }, 200)
            }).off("mouseup.calentim").on("mouseup.calentim", function (t) {
                n.globals.mouseTimer && clearInterval(n.globals.mouseTimer), n.globals.preventMouseClick = !0
            }).off("click.calentim").on("click.calentim", ".calentim-timepicker-minutes-up, .calentim-timepicker-minutes-down, .calentim-timepicker-hours-up, .calentim-timepicker-hours-down", function (t) {
                n.globals.preventMouseClick || i(v(this)), n.globals.preventMouseClick = !1
            }), this.timepickers.find(".calentim-timepicker-hours-wrapper, .calentim-timepicker-minutes-wrapper").off("mousewheel.calentim DOMMouseScroll.calentim").on("mousewheel.calentim DOMMouseScroll.calentim", function (t) {
                0 < (t.originalEvent.wheelDelta || -t.originalEvent.detail) / 120 ? v(t.currentTarget).hasClass("calentim-timepicker-hours-wrapper") ? i(v(this).siblings(".calentim-timepicker-hour-arrows").find(".calentim-timepicker-hours-up")) : v(t.currentTarget).hasClass("calentim-timepicker-minutes-wrapper") && i(v(this).siblings(".calentim-timepicker-minute-arrows").find(".calentim-timepicker-minutes-up")) : v(t.currentTarget).hasClass("calentim-timepicker-hours-wrapper") ? i(v(this).siblings(".calentim-timepicker-hour-arrows").find(".calentim-timepicker-hours-down")) : v(t.currentTarget).hasClass("calentim-timepicker-minutes-wrapper") && i(v(this).siblings(".calentim-timepicker-minute-arrows").find(".calentim-timepicker-minutes-down")), n.stopBubbling(t)
            }), this.globals.isMobile && this.timepickers.find(".calentim-timepicker-minutes, .calentim-timepicker-hours").each(function () {
                var t = new Hammer(this);
                t.get("pan").set({
                    direction: Hammer.DIRECTION_VERTICAL
                }), t.on("panmove", n.panThrottle(function (t) {
                    var e = v(t.target);
                    return 0 < t.velocityY ? e.hasClass("calentim-timepicker-hours-wrapper") || 0 < e.parents(".calentim-timepicker-hours-wrapper").length ? (i(e.parents(".calentim-timepicker").find(".calentim-timepicker-hours-up")), n.stopBubbling(t.srcEvent)) : (e.hasClass("calentim-timepicker-minutes-wrapper") || 0 < e.parents(".calentim-timepicker-minutes-wrapper").length) && (i(e.parents(".calentim-timepicker").find(".calentim-timepicker-minutes-up")), n.stopBubbling(t.srcEvent)) : e.hasClass("calentim-timepicker-hours-wrapper") || 0 < e.parents(".calentim-timepicker-hours-wrapper").length ? (i(e.parents(".calentim-timepicker").find(".calentim-timepicker-hours-down")), n.stopBubbling(t.srcEvent)) : (e.hasClass("calentim-timepicker-minutes-wrapper") || 0 < e.parents(".calentim-timepicker-minutes-wrapper").length) && (i(e.parents(".calentim-timepicker").find(".calentim-timepicker-minutes-down")), n.stopBubbling(t.srcEvent)), !1
                }))
            }), this.timepickers.find(".calentim-timepicker-ampm > div").off("click.calentim").on("click.calentim", function () {
                var t;
                if (v(this).hasClass("calentim-ampm-selected")) return !1;
                v(this).addClass("calentim-ampm-selected").siblings().removeClass("calentim-ampm-selected"), n.updateInput(!1, !1), n.config.startDate && (t = n.config.startDate.clone(), n.config.startDate = n.TimeInsideLimits(n.config.startDate, "start"), !1 === n.config.startDate.isSame(t) && n.updateTimePickerDisplay()), n.config.endDate && (t = n.config.endDate.clone(), n.config.endDate = n.TimeInsideLimits(n.config.endDate, "end"), !1 === n.config.endDate.isSame(t) && n.updateTimePickerDisplay()), n.updateInput(!1, !0), n.config.ondraw(n)
            })
        },
        panThrottle: function (i) {
            return v.proxy(function () {
                var t = Array.prototype.slice.call(arguments),
                    e = Math.ceil(Math.abs(t[0].deltaY) / 20) || 1;
                this.globals.panScrollPos != e && (i.apply(this, t), this.globals.panScrollPos = e)
            }, this)
        },
        readTimeFromDisplay: function (t) {
            var e = null,
                i = null,
                n = "",
                s = "";
            12 == this.config.hourFormat ? (n = this.timepickers.find(".calentim-timepicker-start .calentim-hour-selected").text() + " " + this.timepickers.find(".calentim-timepicker-start .calentim-minute-selected").text() + " " + this.timepickers.find(".calentim-timepicker-start .calentim-ampm-selected").text(), e = moment(n, "hh mm a", this.config.locale), !1 === this.config.singleDate && (s = this.timepickers.find(".calentim-timepicker-end .calentim-hour-selected").text() + " " + this.timepickers.find(".calentim-timepicker-end .calentim-minute-selected").text() + " " + this.timepickers.find(".calentim-timepicker-end .calentim-ampm-selected").text(), i = moment(s, "hh mm a", this.config.locale))) : (n = this.timepickers.find(".calentim-timepicker-start .calentim-hour-selected").text() + " " + this.timepickers.find(".calentim-timepicker-start .calentim-minute-selected").text(), e = moment(n, "HH mm", this.config.locale), !1 === this.config.singleDate && (s = this.timepickers.find(".calentim-timepicker-end .calentim-hour-selected").text() + " " + this.timepickers.find(".calentim-timepicker-end .calentim-minute-selected").text(), i = moment(s, "HH mm", this.config.locale))), e.isValid() && null !== this.config.startDate && this.config.startDate.hours(e.hours()).minutes(e.minutes()).locale(this.config.locale), !1 === this.config.singleDate && i.isValid() && null !== this.config.endDate && this.config.endDate.hours(i.hours()).minutes(i.minutes()).locale(this.config.locale), t && (e && (this.globals.startTimeBackup = e.clone()), i && !1 === this.config.singleDate && (this.globals.endTimeBackup = i.clone()))
        },
        backupTimePickers: function () {
            this.readTimeFromDisplay(!0)
        },
        restoreTimePickers: function () {
            12 == this.config.hourFormat ? (this.globals.startTimeBackup && this.setStartTimeValue(parseInt(this.globals.startTimeBackup.clone().locale("en").format("hh"), 10), parseInt(this.globals.startTimeBackup.clone().locale("en").format("mm"), 10), this.globals.startTimeBackup.clone().locale("en").format("a")), !this.config.singleDate && this.globals.endTimeBackup && this.setEndTimeValue(parseInt(this.globals.endTimeBackup.clone().locale("en").format("hh"), 10), parseInt(this.globals.endTimeBackup.clone().locale("en").format("mm"), 10), this.globals.endTimeBackup.clone().locale("en").format("a"))) : (this.globals.startTimeBackup && this.setStartTimeValue(parseInt(this.globals.startTimeBackup.clone().locale("en").format("HH"), 10), parseInt(this.globals.startTimeBackup.clone().locale("en").format("mm"), 10), null), !this.config.singleDate && this.globals.endTimeBackup && this.setEndTimeValue(parseInt(this.globals.endTimeBackup.clone().locale("en").format("HH"), 10), parseInt(this.globals.endTimeBackup.clone().locale("en").format("mm"), 10), null))
        },
        updateTimePickerDisplay: function () {
            if (this.timepickers !== h) {
                if (null !== this.config.startDate) {
                    var t = this.config.startDate.clone().locale("en").set({
                            minute: 1 != this.config.minuteSteps ? Math.round(this.config.startDate.minutes() / this.config.minuteSteps) * this.config.minuteSteps : this.config.startDate.minutes()
                        }),
                        e = t.hours(),
                        i = t.minutes(),
                        n = null;
                    if (12 == this.config.hourFormat) {
                        var s = t.format("hh mm a").split(" ");
                        e = parseInt(s[0], 10), n = s[2].toLowerCase()
                    }
                    this.setStartTimeValue(e, i, n)
                }
                if (null !== this.config.endDate) {
                    var a = this.config.endDate.clone().locale("en").set({
                            minute: 1 != this.config.minuteSteps ? Math.round(this.config.endDate.minutes() / this.config.minuteSteps) * this.config.minuteSteps : this.config.endDate.minutes()
                        }),
                        o = a.hours(),
                        r = a.minutes(),
                        l = null;
                    if (12 == this.config.hourFormat) {
                        var c = a.format("hh mm a").split(" ");
                        o = parseInt(c[0], 10), l = c[2].toLowerCase()
                    }
                    this.setEndTimeValue(o, r, l)
                }
            }
            this.TimePickerOutOfLimitView()
        },
        setStartTimeValue: function (t, e, i) {
            var n = 12 == this.config.hourFormat && this.config.dontPrefixHours ? "  " : "00",
                s = this.timepickers.find(".calentim-timepicker-start"),
                a = s.find(".calentim-timepicker-hours");
            a.data("value", t);
            var o = a.data();
            o && o.hasOwnProperty("value") && (a.find(".calentim-hour-selected").text(this.localizeNumbers((n + o.value).slice(-2))), a.find(this.config.reverseTimepickerArrows ? ".calentim-hour-selected-next" : ".calentim-hour-selected-prev").text(this.localizeNumbers(o.value - o.step < o.min ? (n + o.max).slice(-2) : (n + (o.value - o.step)).slice(-2))), a.find(this.config.reverseTimepickerArrows ? ".calentim-hour-selected-prev" : ".calentim-hour-selected-next").text(this.localizeNumbers(o.value + o.step > o.max ? (n + o.min).slice(-2) : (n + (o.value + o.step)).slice(-2))));
            var r = s.find(".calentim-timepicker-minutes");
            r.data("value", e), (o = r.data()) && o.hasOwnProperty("value") && (r.find(".calentim-minute-selected").text(this.localizeNumbers(("00" + o.value).slice(-2))), r.find(this.config.reverseTimepickerArrows ? ".calentim-minute-selected-next" : ".calentim-minute-selected-prev").text(this.localizeNumbers(o.value - o.step < o.min ? ("00" + o.max).slice(-2) : ("00" + (o.value - o.step)).slice(-2))), r.find(this.config.reverseTimepickerArrows ? ".calentim-minute-selected-prev" : ".calentim-minute-selected-next").text(this.localizeNumbers(o.value + o.step > o.max ? ("00" + o.min).slice(-2) : ("00" + (o.value + o.step)).slice(-2)))), null !== i && (s.find(".calentim-ampm-selected").removeClass("calentim-ampm-selected"), s.find(".calentim-timepicker-ampm-" + i).addClass("calentim-ampm-selected"))
        },
        localizeAMPM: function (t) {
            return moment("00:00 " + t, "HH:mm A").locale(this.config.locale).format("A")
        },
        localizeNumbers: function (t) {
            return moment.localeData(this.config.locale).postformat("" + t)
        },
        setEndTimeValue: function (t, e, i) {
            var n = 12 == this.config.hourFormat && this.config.dontPrefixHours ? "  " : "00",
                s = this.timepickers.find(".calentim-timepicker-end"),
                a = s.find(".calentim-timepicker-hours");
            a.data("value", t);
            var o = a.data();
            o && o.hasOwnProperty("value") && (a.find(".calentim-hour-selected").text(this.localizeNumbers((n + o.value).slice(-2))), a.find(this.config.reverseTimepickerArrows ? ".calentim-hour-selected-next" : ".calentim-hour-selected-prev").text(this.localizeNumbers(o.value - o.step < o.min ? (n + o.max).slice(-2) : (n + (o.value - o.step)).slice(-2))), a.find(this.config.reverseTimepickerArrows ? ".calentim-hour-selected-prev" : ".calentim-hour-selected-next").text(this.localizeNumbers(o.value + o.step > o.max ? (n + o.min).slice(-2) : (n + (o.value + o.step)).slice(-2))));
            var r = s.find(".calentim-timepicker-minutes");
            r.data("value", e), (o = r.data()) && o.hasOwnProperty("value") && (r.find(".calentim-minute-selected").text(this.localizeNumbers(("00" + o.value).slice(-2))), r.find(this.config.reverseTimepickerArrows ? ".calentim-minute-selected-next" : ".calentim-minute-selected-prev").text(this.localizeNumbers(o.value - o.step < o.min ? ("00" + o.max).slice(-2) : ("00" + (o.value - o.step)).slice(-2))), r.find(this.config.reverseTimepickerArrows ? ".calentim-minute-selected-prev" : ".calentim-minute-selected-next").text(this.localizeNumbers(o.value + o.step > o.max ? ("00" + o.min).slice(-2) : ("00" + (o.value + o.step)).slice(-2)))), null !== i && (s.find(".calentim-ampm-selected").removeClass("calentim-ampm-selected"), s.find(".calentim-timepicker-ampm-" + i).addClass("calentim-ampm-selected"))
        },
        convertLimits: function (t) {
            var e = moment("00:00", "HH:mm"),
                i = moment("23:59", "HH:mm");
            return t.hasOwnProperty("start") && (e = t.start.hasOwnProperty("ampm") && "string" == typeof t.start.ampm && 0 <= ["am", "pm"].indexOf(t.start.ampm.toLowerCase()) ? moment(t.start.hour + ":" + t.start.minute + " " + t.start.ampm.toLowerCase(), "h:m a") : moment(t.start.hour + ":" + t.start.minute, "H m"), t.hasOwnProperty("end") && (i = t.end.hasOwnProperty("ampm") && "string" == typeof t.end.ampm && 0 <= ["am", "pm"].indexOf(t.end.ampm.toLowerCase()) ? moment(t.end.hour + ":" + t.end.minute + " " + t.end.ampm.toLowerCase(), "h:m a") : moment(t.end.hour + ":" + t.end.minute, "H m"))), {
                start: {
                    hour: e.hour(),
                    minute: e.minute()
                },
                end: {
                    hour: i.hour(),
                    minute: i.minute()
                }
            }
        },
        fixLimits: function (t) {
            var e = [{
                start: {
                    hour: 0,
                    minute: 0,
                    ampm: null
                },
                end: {
                    hour: 23,
                    minute: 59,
                    ampm: null
                }
            }];
            if (!t) return e;
            Array.isArray(t) || (t = [t]);
            var i;
            for (l = 0, len = t.length; l < len; l++)
                if (0 == (i = t[l], !void 0 && "object" == typeof i && i.hasOwnProperty("start") && i.hasOwnProperty("end") && i.start.hasOwnProperty("hour") && 0 == isNaN(i.start.hour) && i.start.hasOwnProperty("minute") && 0 == isNaN(i.start.minute) && i.start.hasOwnProperty("ampm") && ("am" == i.start.ampm || "pm" == i.start.ampm || null == i.start.ampm) && i.end.hasOwnProperty("hour") && 0 == isNaN(i.end.hour) && i.end.hasOwnProperty("minute") && 0 == isNaN(i.end.minute) && i.end.hasOwnProperty("ampm") && ("am" == i.end.ampm || "pm" == i.end.ampm || null == i.end.ampm))) return e;
            return t
        },
        TimeInsideLimits: function (t, e) {
            direction = "undefined" == typeof direction ? "static" : direction;
            for (var i = this.fixLimits(this.config.limitTimeForDay(t)), n = [], s = 0, a = i.length; s < a; s++)
                if (n[s] = this.convertLimits(i[s]), n[s].startLimit = t.clone().hour(n[s].start.hour).minute(n[s].start.minute), n[s].endLimit = t.clone().hour(n[s].end.hour).minute(n[s].end.minute), t.isBetween(n[s].startLimit, n[s].endLimit, null, "[]")) return t;
            if ("end" == e) {
                for (s = 0; s < a; s++)
                    if (n[s].startLimit.isAfter(t)) return n[s].startLimit;
                return n[0].startLimit
            }
            if (moment.isMoment(e)) {
                for (s = 0; s < a && !e.isBetween(n[s].startLimit, n[s].endLimit, null, "[]"); s++);
                return e.isAfter(t) ? n[0 == s ? a - 1 : s - 1].endLimit : n[s == a - 1 ? 0 : s + 1].startLimit
            }
            for (s = 0; s < a; s++)
                if (n[s].endLimit.isBefore(t)) return n[s].endLimit;
            return n[a - 1].endLimit
        },
        TimePickerOutOfLimitView: function () {
            var t, e, i, n, s;
            this.config.startDate && this.timepickers && (t = this.config.startDate.clone(), i = this.convertLimits(this.config.limitTimeForDay(t.clone())), n = t.clone().hour(i.start.hour).minute(i.start.minute), s = t.clone().hour(i.end.hour).minute(i.end.minute), t.clone().add(1, "hour").isAfter(s, "hour") && this.timepickers.find(".calentim-timepicker-start .calentim-timepicker-hours .calentim-hour-selected-next").html(" "), t.clone().add(-1, "hour").isBefore(n, "hour") && this.timepickers.find(".calentim-timepicker-start .calentim-timepicker-hours .calentim-hour-selected-prev").html(" "), t.clone().add(1, "minute").isAfter(s, "minute") && this.timepickers.find(".calentim-timepicker-start .calentim-timepicker-minutes .calentim-minute-selected-next").html(" "), t.clone().add(-1, "minute").isBefore(n, "minute") && this.timepickers.find(".calentim-timepicker-start .calentim-timepicker-minutes .calentim-minute-selected-prev").html(" ")), this.config.endDate && this.timepickers && (e = this.config.endDate.clone(), i = this.convertLimits(this.config.limitTimeForDay(e.clone())), n = e.clone().hour(i.start.hour).minute(i.start.minute), s = e.clone().hour(i.end.hour).minute(i.end.minute), e.clone().add(1, "hour").isAfter(s, "hour") && this.timepickers.find(".calentim-timepicker-end .calentim-timepicker-hours .calentim-hour-selected-next").html(" "), e.clone().add(-1, "hour").isBefore(n, "hour") && this.timepickers.find(".calentim-timepicker-end .calentim-timepicker-hours .calentim-hour-selected-prev").html(" "), e.clone().add(1, "minute").isAfter(s, "minute") && this.timepickers.find(".calentim-timepicker-end .calentim-timepicker-minutes .calentim-minute-selected-next").html(" "), e.clone().add(-1, "minute").isBefore(n, "minute") && this.timepickers.find(".calentim-timepicker-end .calentim-timepicker-minutes .calentim-minute-selected-prev").html(" "))
        },
        drawFooter: function () {
            if (!1 === this.config.singleDate && !0 === this.config.showFooter && !0 === this.config.showCalendars) {
                "horizontal" === this.config.rangeOrientation || this.globals.isMobile ? this.input.append("<div class='calentim-ranges'></div>") : (this.input.addClass("calentim-input-vertical-range"), this.input.wrapInner("<div class='calentim-left'></div>"), v("<div class='calentim-right' style='max-width: " + this.config.verticalRangeWidth + "px; min-width: " + this.config.verticalRangeWidth + "px'><div class='calentim-ranges'></div></div>").insertAfter(this.input.find(".calentim-left")));
                var t = this.input.find(".calentim-ranges");
                for (var e in t.append("<span class='calentim-range-header-container'>" + this.config.rangeIcon + "<div class='calentim-range-header'>" + this.config.rangeLabel + "</div></span>"), this.config.ranges) t.append("<div class='calentim-range" + (this.config.ranges[e].selected ? " calentim-range-selected" : "") + "' data-id='" + e + "'>" + this.config.ranges[e].title + "</div>")
            }
            if (this.globals.isMobile && (!0 !== this.config.singleDate && !1 !== this.config.showFooter || this.input.append("<div class='calentim-filler'></div>")), (this.globals.isMobile && !this.config.inline || !this.globals.isMobile && !this.config.inline && this.config.showButtons) && ("horizontal" === this.config.rangeOrientation || this.globals.isMobile ? this.input.append("<div class='calentim-footer'></div>") : this.input.find(".calentim-right").append("<div class='calentim-footer'></div>"), this.footer = this.input.find(".calentim-footer"), this.footer.append("<button type='button' class='calentim-cancel'>" + this.config.cancelLabel + "</button>"), this.footer.append("<button type='button' class='calentim-apply'>" + this.config.applyLabel + "</button>"), !1 === this.globals.firstValueSelected && !0 === this.config.startEmpty && void 0 !== this.footer || this.globals.isMobile && !1 === this.globals.endSelected)) {
                var i = void 0 === this.footer ? [] : this.footer.find(".calentim-apply");
                0 < i.length && i.attr("disabled", "disabled")
            }
        },
        drawNextMonth: function (t) {
            if (t = t || o.event, 1 == this.config.hideOutOfRange && this.config.maxDate && this.globals.currentDate.clone().add(this.config.calendarCount, "month").isAfter(this.config.maxDate, "month")) return !1;
            if (null === this.globals.swipeTimeout) {
                var e = this;
                this.globals.swipeTimeout = setTimeout(function () {
                    if (!0 === e.config.onbeforemonthchange(e, e.globals.currentDate ? e.globals.currentDate.clone().startOfMonth() : null, "next")) {
                        var t = e.calendars.get(0).scrollTop;
                        e.globals.currentDate.middleOfDay().add(1, "month"), e.reDrawCalendars(), e.calendars.get(0).scrollTop = t, e.config.onaftermonthchange(e, e.globals.currentDate ? e.globals.currentDate.clone().startOfMonth() : null)
                    }
                    e.globals.swipeTimeout = null
                }, "click" == t.type ? 0 : 100)
            }
            this.stopBubbling(t)
        },
        drawPrevMonth: function (t) {
            if (t = t || o.event, 1 == this.config.hideOutOfRange && this.config.minDate && this.globals.currentDate.clone().add(-1, "month").isBefore(this.config.minDate, "month")) return !1;
            if (null === this.globals.swipeTimeout) {
                var e = this;
                this.globals.swipeTimeout = setTimeout(function () {
                    if (!0 === e.config.onbeforemonthchange(e, e.globals.currentDate ? e.globals.currentDate.clone().startOfMonth() : null, "prev")) {
                        var t = e.calendars.get(0).scrollTop;
                        e.globals.currentDate.middleOfDay().subtract(1, "month"), e.reDrawCalendars(), e.calendars.get(0).scrollTop = t, e.config.onaftermonthchange(e, e.globals.currentDate ? e.globals.currentDate.clone().startOfMonth() : null)
                    }
                    e.globals.swipeTimeout = null
                }, 100)
            }
            this.stopBubbling(t)
        },
        cellClicked: function (t) {
            (t = t || o.event).target = t.target || t.srcElement, !1 === v(t.target).hasClass("calentim-day") && (t.target = v(t.target).closest(".calentim-day").get(0));
            var e = v(t.target).data("value"),
                i = moment.unix(e).middleOfDay();
            if (0 == this.config.validateClick(i)) return !1;
            if (!1 === this.config.singleDate)
                if (!1 === this.globals.startSelected) {
                    null !== this.config.startDate && (this.globals.startDateBackup = this.config.startDate.clone()), this.config.startDate = i.clone(), this.config.endDate = null, this.globals.startSelected = !0, this.globals.endSelected = !1, this.readTimeFromDisplay(!1), i = this.config.startDate.clone(), this.config.startDate = this.TimeInsideLimits(this.config.startDate, "start"), !1 === this.config.startDate.isSame(i) && this.updateTimePickerDisplay();
                    var n = void 0 === this.footer ? [] : this.footer.find(".calentim-apply");
                    0 < n.length && n.attr("disabled", "disabled"), this.config.onfirstselect(this, this.config.startDate.clone())
                } else {
                    if (i.isBefore(this.config.startDate)) {
                        var s = this.config.startDate.clone();
                        this.config.startDate = i.clone(), i = s
                    }
                    i.diff(this.config.startDate, "day") < this.config.minSelectedDays ? (this.globals.startSelected = !1, this.fetchInputs()) : (this.globals.startDateBackup = null, this.config.endDate = i.clone(), this.globals.endSelected = !0, this.globals.startSelected = !1, this.globals.hoverDate = null, this.readTimeFromDisplay(!1), i = this.config.endDate.clone(), this.config.endDate = this.TimeInsideLimits(this.config.endDate, "end"), !1 === this.config.endDate.isSame(i) && this.updateTimePickerDisplay(), !0 === this.config.onbeforeselect(this, this.config.startDate ? this.config.startDate.clone() : null, this.config.endDate ? this.config.endDate.clone() : null) && !0 === this.checkRangeContinuity() ? (this.globals.firstValueSelected = !0, this.clearRangeSelection(), this.updateInput(!0, !1)) : this.fetchInputs(), this.config.autoCloseOnSelect && !1 === this.config.inline ? this.hideDropdown(t) : void 0 !== this.footer && null !== this.config.endDate && this.footer.find(".calentim-apply").removeAttr("disabled"))
                }
            else this.config.startDate = i.clone(), this.config.endDate = this.config.startDate.clone(), this.globals.endSelected = !0, this.globals.startSelected = !1, this.globals.hoverDate = null, this.readTimeFromDisplay(), i = this.config.startDate.clone(), this.config.startDate = this.TimeInsideLimits(this.config.startDate, "start"), !1 === this.config.startDate.isSame(i) && this.updateTimePickerDisplay(), !0 === this.config.onbeforeselect(this, this.config.startDate ? this.config.startDate.clone() : null, this.config.endDate ? this.config.endDate.clone() : null) ? (this.globals.firstValueSelected = !0, this.clearRangeSelection(), this.updateInput(!0, !1)) : this.fetchInputs(), this.config.autoCloseOnSelect && !1 === this.config.inline ? this.hideDropdown(t) : void 0 !== this.footer && null !== this.config.endDate && this.footer.find(".calentim-apply").removeAttr("disabled");
            return this.input.is(":visible") && (this.reDrawCells(), this.updateHeader()), this.stopBubbling(t), !1
        },
        checkRangeContinuity: function () {
            var t = this.config.endDate.diff(this.config.startDate, "days");
            if (this.config.singleDate || 0 == t) return !0;
            var e = moment(this.config.startDate).middleOfDay();
            if (1 == this.config.disableOnlyStart) return !1 === this.isDisabled(this.config.startDate, this.config.isHotelBooking);
            if (1 == this.config.disableOnlyEnd) return !1 === this.isDisabled(this.config.endDate, this.config.isHotelBooking);
            if (this.config.continuous) {
                var i = e.middleOfDay().unix();
                if (1 == this.isDisabled(i, !1) && (!this.config.isHotelBooking || 1 === this.getDisabledLevel(i))) return !1;
                if (0 == e.isSame(this.config.endDate, "day")) {
                    e.middleOfDay().add(1, "days");
                    for (var n = 0; n <= t - 2; n++) {
                        if (i = e.middleOfDay().unix(), this.getDisabledLevel(i) !== h) return !1;
                        e.add(1, "days")
                    }
                }
                if (i = e.middleOfDay().unix(), 1 == this.isDisabled(i, !1) && (!this.config.isHotelBooking || 3 === this.getDisabledLevel(i))) return !1
            }
            return !0
        },
        isDisabledOnDraw: function (t) {
            var e = moment(t).middleOfDay();
            if (!0 === this.config.disableDays(e)) return !0;
            for (var i = 0; i < this.config.disabledRanges.length; i++) {
                var n = this.config.disabledRanges[i];
                if (e.isBetween(n.start, n.end, "day", "[]")) return !0
            }
        },
        isDisabled: function (t, e) {
            return h === e && (e = !1), (1 != this.config.disableOnlyStart || 1 != this.globals.startSelected) && ((1 != this.config.disableOnlyEnd || 0 != this.globals.startSelected) && ("object" == typeof t && null !== t && (t = t.clone().middleOfDay().unix()), e && this.config.isHotelBooking ? 2 === this.globals.disabledDays[t] : this.globals.disabledDays[t] !== h))
        },
        getDisabledLevel: function (t) {
            return "object" == typeof t && null !== t && (t = t.clone().middleOfDay().unix()), this.globals.disabledDays[t]
        },
        cellHovered: function (t) {
            (t = t || o.event).target = t.target || t.srcElement, !1 === v(t.target).hasClass("calentim-day") && (t.target = v(t.target).closest(".calentim-day").get(0));
            var e = v(t.target).data("value");
            this.globals.hoverDate = moment.unix(e).middleOfDay(), !(this.globals.keyboardHoverDate = null) === this.globals.startSelected && this.reDrawCells(), this.stopBubbling(t)
        },
        reDrawCalendars: function () {
            this.backupTimePickers(), this.input.empty(), this.drawUserInterface(), this.restoreTimePickers(), this.container.focus()
        },
        monthSwitchClicked: function () {
            if (!(0 < this.calendars.find(".calentim-month-selector").length)) {
                var e = this;
                this.calendars.get(0).scrollTop = 0;
                for (var t = v("<div class='calentim-month-selector'></div>").appendTo(this.calendars), i = this.globals.currentDate.get("month"), n = this.globals.currentDate.clone(), s = 0; s < 12; s++) n.month(s), this.config.hideOutOfRange && (n.isBefore(this.config.minDate, "month") || n.isAfter(this.config.maxDate, "month")) ? t.append("<div class='calentim-ms-month-disabled'> </div>") : t.append("<div class='calentim-ms-month" + (i == s ? " current" : "") + "' data-month='" + s + "'>" + (this.config.numericMonthSelector ? s + 1 : moment({
                    day: 15,
                    hour: 12,
                    month: s
                }).locale(this.config.locale).format(this.config.monthSwitcherFormat)) + "</div>");
                t.css("display", "block"), this.optimizeFontSize(t.find(".calentim-ms-month")), t.find(".calentim-ms-month").off("click").on("click", function (t) {
                    e.globals.currentDate.month(v(this).data("month")), e.config.onaftermonthchange(e, e.globals.currentDate ? e.globals.currentDate.clone().startOfMonth() : null), e.calendars.find(".calentim-month-selector").remove(), e.reDrawCalendars(), e.stopBubbling(t)
                })
            }
        },
        drawYearSwitch: function (t, e) {
            t.empty();
            var i = this.globals.currentDate.year();
            t.data("year", e);
            var n = e - 6,
                s = e + 6;
            this.config.hideOutOfRange && (moment(n + "-01-01").isBefore(this.config.minDate, "year") || moment(n + "-12-31").isAfter(this.config.maxDate, "year")) ? t.append("<div class='calentim-ys-year-disabled'> </div>") : t.append("<div class='calentim-ys-year-prev'><i class='fa fa-angle-double-left'></i></div>");
            for (var a = e - 6; a < e + 7; a++) this.config.hideOutOfRange && (moment(a + "-06-01").isBefore(this.config.minDate, "year") || moment(a + "-06-01").isAfter(this.config.maxDate, "year")) ? t.append("<div class='calentim-ys-year-disabled'> </div>") : t.append("<div class='calentim-ys-year" + (i == a ? " current" : "") + "' data-year='" + a + "'>" + this.localizeNumbers(a) + "</div>");
            this.config.hideOutOfRange && (moment(s + "-01-01").isBefore(this.config.minDate, "year") || moment(s + "-12-31").isAfter(this.config.maxDate, "year")) ? t.append("<div class='calentim-ys-year-disabled'> </div>") : t.append("<div class='calentim-ys-year-next'><i class='fa fa-angle-double-right'></i></div>")
        },
        yearSwitchClicked: function () {
            if (!(0 < this.calendars.find(".calentim-year-selector").length)) {
                var i = this;
                this.calendars.get(0).scrollTop = 0;
                var n = v("<div class='calentim-year-selector'></div>").appendTo(this.calendars),
                    t = this.globals.currentDate.get("year");
                this.drawYearSwitch(n, t), n.css("display", "block"), this.optimizeFontSize(n.find(".calentim-ys-year")), v(r).off("click.calentimys").on("click.calentimys", ".calentim-ys-year", function (t) {
                    i.globals.currentDate.year(v(this).data("year")), i.config.onafteryearchange(i, i.globals.currentDate ? i.globals.currentDate.clone().startOf("year") : null), i.reDrawCalendars(), i.calendars.find(".calentim-year-selector").remove(), 1 == i.config.DOBCalendar && i.calendars.find(".calentim-calendar").first().find(".calentim-month-switch").click(), i.stopBubbling(t)
                }), v(r).off("click.calentimysprev").on("click.calentimysprev", ".calentim-ys-year-prev", function (t) {
                    var e = n.data("year") - 13;
                    n.data("year", e), i.drawYearSwitch(n, e), i.stopBubbling(t)
                }), v(r).off("click.calentimysnext").on("click.calentimysnext", ".calentim-ys-year-next", function (t) {
                    var e = n.data("year") + 13;
                    n.data("year", e), i.drawYearSwitch(n, e), i.stopBubbling(t)
                })
            }
        },
        optimizeFontSize: function (t) {
            t.each(function (t, e) {
                (e = v(e)).wrapInner("<span class='adjust-subject'></span>").prepend("<span class='font-adjuster'>i</span>");
                var i = e.find(".adjust-subject"),
                    n = e.find(".font-adjuster");
                if (i.innerHeight() === n.innerHeight()) n.remove(), i.contents().unwrap();
                else {
                    for (var s = 0; i.innerHeight() !== n.innerHeight() && s < 16;) {
                        var a = 0;
                        if (a = void 0 !== o.getComputedStyle ? parseFloat(o.getComputedStyle(n.get(0), null).getPropertyValue("font-size")) : parseFloat(n.css("font-size")), i.parent().css("font-size", a - 1 + "px"), n.css("font-size", a - 1 + "px"), a < 2) break;
                        s++
                    }
                    n.remove(), i.contents().unwrap()
                }
            })
        },
        showDropdown: function (t) {
            var e = t || o.event || jQuery.Event("click", {
                    target: this.elem
                }),
                i = e.target || e.srcElement;
            return (!this.globals.isMobile && "none" == this.container.css("display") || this.globals.isMobile && "none" == this.input.css("display")) && (i !== this.elem && (this.globals.dontHideOnce = !0, this.globals.initiator = i), null !== this.config.startDate && (this.globals.startDateInitial = this.config.startDate.clone()), null !== this.config.endDate && (this.globals.endDateInitial = this.config.endDate.clone()), this.fetchInputs(), !1 !== this.config.startEmpty && !this.globals.firstValueSelected || (this.globals.currentDate = moment(this.config.startDate)), 0 == this.globals.currentDate.isValid() && (this.globals.currentDate = moment().locale(this.config.locale).middleOfDay()), this.config.onbeforeshow(this), this.globals.isMobile ? (this.input.css({
                display: "flex"
            }), this.config.inline || this.overlay.show(), v("body").addClass("calentim-open")) : this.container.css({
                display: "block"
            }), this.globals.lastScrollY = o.scrollY || o.pageYOffset || r.documentElement.scrollTop, this.reDrawCalendars(), 1 == this.config.DOBCalendar && this.calendars.find(".calentim-calendar").first().find(".calentim-year-switch").click(), this.config.onaftershow(this)), !1
        },
        hideDropdown: function (t) {
            var e = t || o.event || jQuery.Event("click", {
                    target: "body"
                }),
                i = e.target || e.srcElement;
            if (this.globals.initiator !== i) return !1 === this.config.inline && (!this.globals.isMobile && "none" !== this.container.css("display") || this.globals.isMobile && "none" !== this.input.css("display")) && (this.config.onbeforehide(this), this.globals.isMobile ? (this.input.css({
                display: "none"
            }), v("body").removeClass("calentim-open"), this.config.inline || this.overlay.hide()) : this.container.css({
                display: "none"
            }), (this.globals.hoverDate = null) !== this.globals.startDateBackup && (this.config.startDate = this.globals.startDateBackup, this.globals.startSelected = !1), this.config.onafterhide(this)), !1
        },
        reDrawCells: function () {
            var t = null !== this.config.startDate ? this.config.startDate.clone().middleOfDay().unix() : null,
                e = null !== this.config.endDate ? this.config.endDate.clone().middleOfDay().unix() : null,
                i = null !== this.config.minDate ? this.config.minDate.clone().middleOfDay().unix() : null,
                n = null !== this.config.maxDate ? this.config.maxDate.clone().middleOfDay().unix() : null,
                s = null !== this.globals.hoverDate ? this.globals.hoverDate.clone().middleOfDay().unix() : null,
                a = null !== this.globals.keyboardHoverDate ? this.globals.keyboardHoverDate.clone().middleOfDay().unix() : null,
                o = moment().middleOfDay().unix();
            this.lastHoverStatus = !1;
            for (var r = 0; r < this.config.calendarCount; r++)
                for (var l = this.calendars.find(".calentim-calendar").eq(r), c = l.find(".calentim-days-container > div").not(".calentim-dayofweek, .calentim-weeknumber"), h = l.data("month"), d = 0; d < c.length; d++) {
                    var m = v(c[d]),
                        f = parseInt(m.attr("data-value")),
                        u = moment.unix(f).middleOfDay().locale(this.config.locale),
                        p = "calentim-day",
                        g = u.day();
                    6 != g && 0 !== g || (p += " calentim-weekend"), f === o && (p += " calentim-today"), p = this.addDisabledStyles(m, u, f, p, i, n, h), p = this.addSelectedStyles(f, p, t, e, i, n), p = this.addHoverStyles(m, f, p, this, t, s, a), m.attr("class", p)
                }
            this.attachEvents(), this.config.ondraw(this)
        },
        addSelectedStyles: function (t, e, i, n, s, a) {
            var o = this;
            return !1 !== o.config.startEmpty && !o.globals.firstValueSelected || (!1 === o.config.singleDate && null !== i && i === t && (e += " calentim-start"), !1 === o.config.singleDate && null !== n && n === t && (e += " calentim-end"), !1 === o.config.singleDate && null !== i && null !== n && t <= n && i <= t && (e += " calentim-selected"), !0 === o.config.singleDate && null !== i && i === t && (e += " calentim-selected calentim-start calentim-end")), e
        },
        addHoverStyles: function (t, e, i, n, s, a, o) {
            return i.replace("calentim-hovered", "").replace("calentim-hovered-last", "").replace("calentim-hovered-first", ""), !0 === this.globals.startSelected && !1 === this.globals.endSelected && null !== a && (a <= e && e <= s || e <= a && s <= e) && (i += " calentim-hovered"), !0 === this.config.enableKeyboard && null !== o && (!1 === this.globals.startSelected ? o == e && (i += " calentim-hovered") : (e <= s && o <= e || s <= e && e <= o) && (i += " calentim-hovered")), !1 === this.lastHoverStatus && 0 < i.indexOf("calentim-hovered") && (this.lastHoverStatus = !0, i += " calentim-hovered-first"), !0 === this.lastHoverStatus && i.indexOf("calentim-hovered") < 0 && (t.prev(".calentim-day").addClass("calentim-hovered-last"), this.lastHoverStatus = !1), i
        },
        addDisabledStyles: function (t, e, i, n, s, a, o) {
            if (this.isDisabled(i))
                if (0 == this.config.isHotelBooking) n = n.replace("calentim-day", "calentim-disabled calentim-disabled-range");
                else switch (this.globals.disabledDays[i]) {
                    case 1:
                        n = n.replace("calentim-day", "calentim-day calentim-disabled-range calentim-disabled-range-start");
                        break;
                    case 2:
                        n = n.replace("calentim-day", "calentim-disabled calentim-disabled-range");
                        break;
                    case 3:
                        n = n.replace("calentim-day", "calentim-day calentim-disabled-range calentim-disabled-range-end")
                } else(null != a && a < i || null != s && i < s) && (n = n = n.replace("calentim-day", "calentim-disabled"));
            return e.month() != o && (n += " calentim-not-in-month"), n
        },
        rangeClicked: function (t) {
            if ((t = t || o.event).target = t.target || t.srcElement, !1 === v(t.target).hasClass("calentim-range") && (t.target = v(t.target).closest(".calentim-range").get(0)), t.target.hasAttribute("data-id")) {
                var e = v(t.target).attr("data-id");
                return this.globals.currentDate = this.config.ranges[e].startDate.clone().locale(this.config.locale), this.config.startDate = this.config.ranges[e].startDate.clone().locale(this.config.locale), this.config.endDate = this.config.ranges[e].endDate.clone().locale(this.config.locale), !(this.globals.firstValueSelected = !0) === this.checkRangeContinuity() ? this.fetchInputs() : (this.clearRangeSelection(), this.config.ranges[e].selected = !0, this.updateTimePickerDisplay(), this.reDrawCalendars(), this.setViewport(), this.config.onrangeselect(this, this.config.ranges[e]), this.config.autoCloseOnSelect && this.hideDropdown()), this.stopBubbling(t), !1
            }
        },
        setViewport: function () {
            if (!0 === this.globals.isMobile) "none" !== this.input.css("display") && this.container.trigger("calentim:resize");
            else {
                if ("none" !== this.container.css("display") && this.globals.initComplete && !1 === this.globals.isMobile && !1 === this.config.inline) {
                    var t = this.getViewport();
                    switch (this.config.showOn) {
                        case "top":
                            this.config.autoAlign ? this.positionOnTopAlign(t) : this.positionOnTop(!1, t), this.horizontalAlign(t);
                            break;
                        case "left":
                            this.config.autoAlign ? this.positionOnLeftAlign(t) : this.positionOnLeft(!1, t), this.verticalAlign(t);
                            break;
                        case "right":
                            this.config.autoAlign ? this.positionOnRightAlign(t) : this.positionOnRight(!1, t), this.verticalAlign(t);
                            break;
                        case "bottom":
                            this.config.autoAlign ? this.positionOnBottomAlign(t) : this.positionOnBottom(!1, t), this.horizontalAlign(t);
                            break;
                        case "center":
                            this.positionOnCenter(t);
                            break;
                        default:
                            this.config.autoAlign ? this.positionOnBottomAlign(t) : this.positionOnBottom(!1, t), this.horizontalAlign(t)
                    }
                }
                if ("horizontal" !== this.config.rangeOrientation) {
                    var e = this.input.find(".calentim-header").outerHeight() + this.input.find(".calentim-calendars").outerHeight() + (0 < this.input.find(".calentim-footer").length ? this.input.find(".calentim-footer").outerHeight() : 0) + (0 < this.input.find(".calentim-timepickers").length ? this.input.find(".calentim-timepickers").outerHeight() : 0);
                    this.input.find(".calentim-right").css("max-height", e)
                }
            }
        },
        getDropdownPos: function (t) {
            var e = this.getDimensions(this.$elem, !0),
                i = this.getDimensions(this.container, !0),
                n = parseInt(this.input.css("margin-left"), 10),
                s = parseFloat(this.container.find("div[class*='calentim-box-arrow']").first().outerHeight() / 2);
            switch (t) {
                case "left":
                    switch (this.config.arrowOn) {
                        case "top":
                            return {
                                top: e.offsetTop - n - s - e.height / 2,
                                left: e.offsetLeft - i.width - n,
                                arrow: 0
                            };
                        case "center":
                            return {
                                top: e.offsetTop - n - i.height / 2,
                                left: e.offsetLeft - i.width - n,
                                arrow: (i.height - 2 * s) / 2 - e.height / 2
                            };
                        case "bottom":
                            return {
                                top: e.offsetTop - i.height + e.height + 2 * n + s,
                                left: e.offsetLeft - i.width - n,
                                arrow: i.height - 4 * s - 3 * n - e.height / 2
                            };
                        default:
                            return {
                                top: e.offsetTop - n - s - e.height / 2,
                                left: e.offsetLeft - i.width - n,
                                arrow: 0
                            }
                    }
                    break;
                case "right":
                    switch (this.config.arrowOn) {
                        case "top":
                            return {
                                top: e.offsetTop - n - s - e.height / 2,
                                left: e.offsetLeft + e.width + n,
                                arrow: 0
                            };
                        case "center":
                            return {
                                top: e.offsetTop - n - i.height / 2,
                                left: e.offsetLeft + e.width + n,
                                arrow: (i.height - 2 * s) / 2 - e.height / 2
                            };
                        case "bottom":
                            return {
                                top: e.offsetTop - i.height + e.height + 2 * n + s,
                                left: e.offsetLeft + e.width + n,
                                arrow: i.height - 4 * s - 3 * n - e.height / 2
                            };
                        default:
                            return {
                                top: e.offsetTop - n - s - e.height / 2,
                                left: e.offsetLeft + e.width + n,
                                arrow: 0
                            }
                    }
                    break;
                case "top":
                    switch (this.config.arrowOn) {
                        case "left":
                            return {
                                top: e.offsetTop - i.height - n,
                                left: e.offsetLeft - n,
                                arrow: 0
                            };
                        case "center":
                            return {
                                top: e.offsetTop - i.height - n,
                                left: e.offsetLeft - (i.width - 2 * n - e.width) / 2,
                                arrow: (i.width - 5 * s) / 2
                            };
                        case "right":
                            return {
                                top: e.offsetTop - i.height - n,
                                left: e.offsetLeft - (i.width - e.width) + n,
                                arrow: i.width - 5 * s + n
                            };
                        default:
                            return {
                                top: e.offsetTop - i.height - n,
                                left: e.offsetLeft - n,
                                arrow: 0
                            }
                    }
                    break;
                case "bottom":
                    switch (this.config.arrowOn) {
                        case "left":
                            return {
                                top: e.offsetTop + e.height - n + s,
                                left: e.offsetLeft - n,
                                arrow: 0
                            };
                        case "center":
                            return {
                                top: e.offsetTop + e.height - n + s,
                                left: e.offsetLeft - (i.width - 2 * n - e.width) / 2,
                                arrow: (i.width - 5 * s) / 2
                            };
                        case "right":
                            return {
                                top: e.offsetTop + e.height - n + s,
                                left: e.offsetLeft - (i.width - e.width) + n,
                                arrow: i.width - 5 * s + n
                            };
                        default:
                            return {
                                top: e.offsetTop + e.height - n + s,
                                left: e.offsetLeft - n,
                                arrow: 0
                            }
                    }
                    break;
                case "center":
                    switch (this.config.arrowOn) {
                        case "center":
                            return {
                                top: e.offsetTop - n - i.height / 2,
                                left: e.offsetLeft - (i.width - 2 * n - e.width) / 2
                            }
                    }
            }
        },
        verticalAlign: function (t) {
            var e = this.getDimensions(this.container, !0),
                i = t.top - e.offsetTop,
                n = e.offsetTop + e.height - t.bottom;
            0 < i && Math.abs(i) < e.height ? (this.container.css({
                top: function () {
                    return parseFloat(v(this).css("top").replace(/px$/, "")) + i
                }
            }), this.container.find("div[class*='calentim-box-arrow-']").css({
                top: function () {
                    return parseFloat(v(this).css("top").replace(/px$/, "")) - i
                }
            })) : 0 < n && Math.abs(n) < e.height && (this.container.css({
                top: function () {
                    return parseFloat(v(this).css("top").replace(/px$/, "")) - n
                }
            }), this.container.find("div[class*='calentim-box-arrow-']").css({
                top: function () {
                    return parseFloat(v(this).css("top").replace(/px$/, "")) + n
                }
            }))
        },
        horizontalAlign: function (t) {
            var e = this.getDimensions(this.container, !0),
                i = e.offsetLeft + e.width - t.right;
            0 < i && Math.abs(i) < e.width && (this.container.css({
                left: function () {
                    return parseFloat(v(this).css("left").replace(/px$/, "")) - i
                }
            }), this.container.find("div[class*='calentim-box-arrow-']").css({
                left: function () {
                    return parseFloat(v(this).css("left").replace(/px$/, "")) + i
                }
            }))
        },
        positionOnTop: function (t, e) {
            var i = this.getDropdownPos("top");
            if (t) return i;
            this.container.css({
                left: i.left,
                top: i.top
            }), this.container.find("div[class*='calentim-box-arrow-']").css({
                left: i.arrow
            }).attr("class", "calentim-box-arrow-bottom")
        },
        positionOnBottom: function (t, e) {
            var i = this.getDropdownPos("bottom");
            if (t) return i;
            this.container.css({
                left: i.left,
                top: i.top
            }), this.container.find("div[class*='calentim-box-arrow-']").attr("class", "calentim-box-arrow-top").css({
                left: i.arrow
            })
        },
        positionOnLeft: function (t, e) {
            var i = this.getDropdownPos("left");
            if (t) return i;
            this.container.css({
                left: i.left,
                top: i.top + 11
            }), this.container.children("div[class*='calentim-box-arrow-']").attr("class", "calentim-box-arrow-right").css({
                top: i.arrow
            })
        },
        positionOnRight: function (t, e) {
            var i = this.getDropdownPos("right");
            if (t) return i;
            this.container.css({
                left: i.left,
                top: i.top + 11
            }), this.container.children("div[class*='calentim-box-arrow-']").attr("class", "calentim-box-arrow-left").css({
                top: i.arrow
            })
        },
        positionOnCenter: function (t) {
            var e = this.getDropdownPos("center"),
                i = Math.max(e.left + this.container[0].clientWidth - (t.right - 30), 0),
                n = Math.max(e.top + this.container[0].clientHeight - (t.bottom - 30), 0);
            this.config.autoAlign || (n = i = 0), e.left -= i, e.top -= n, this.container.css({
                left: e.left,
                top: e.top
            }), this.container.find("div[class*='calentim-box-arrow-']").remove()
        },
        positionOnBottomAlign: function (t) {
            var e = this.positionOnBottom(!0, t),
                i = this.getDimensions(this.container);
            e.top + i.height < t.bottom ? this.positionOnBottom(!1, t) : this.positionOnTop(!1, t)
        },
        positionOnLeftAlign: function (t) {
            this.positionOnLeft(!0, t).left > t.left - 50 ? this.positionOnLeft(!1, t) : this.positionOnRight(!1, t)
        },
        positionOnRightAlign: function (t) {
            var e = this.positionOnRight(!0, t),
                i = this.getDimensions(this.container);
            e.left + i.width < t.right + 50 ? this.positionOnRight(!1, t) : this.positionOnLeft(!1, t)
        },
        positionOnTopAlign: function (t) {
            this.positionOnTop(!0, t).top > t.top ? this.positionOnTop(!1, t) : this.positionOnBottom(!1, t)
        },
        getDimensions: function (t, e) {
            var i = r.body,
                n = t[0],
                s = t.offset();
            if (t === this.$elem && !1 === this.globals.parentScrollEventsAttached) {
                var a = v.proxy(function () {
                    this.globals.isTicking || (this.globals.isTicking = !0, this.globals.rafID = this.requestAnimFrame(v.proxy(function () {
                        this.setViewport(), this.cancelAnimFrame(this.globals.rafID), this.globals.isTicking = !1
                    }, this)))
                }, this);
                if (n !== i)
                    for (var o = n.parentNode; o !== i && null !== o;) o.scrollHeight > o.offsetHeight && v(o).off("scroll.calentim").on("scroll.calentim", a), o = o.parentNode;
                this.globals.parentScrollEventsAttached = !0
            }
            return {
                width: n.offsetWidth,
                height: n.offsetHeight,
                offsetLeft: s.left,
                offsetTop: s.top
            }
        },
        getViewport: function () {
            var t = this.globals.lastScrollY,
                e = this.globals.lastScrollX,
                i = t + o.innerHeight;
            return {
                top: t,
                left: e,
                right: e + o.innerWidth,
                bottom: i
            }
        },
        attachEvents: function () {
            var t = v.proxy(this.drawNextMonth, this),
                e = v.proxy(this.drawPrevMonth, this),
                i = v.proxy(this.cellClicked, this),
                n = v.proxy(this.cellHovered, this),
                s = v.proxy(this.rangeClicked, this),
                a = v.proxy(this.monthSwitchClicked, this),
                o = v.proxy(this.yearSwitchClicked, this),
                r = "click.calentim";
            if (this.container.find(".calentim-next").off(r).one(r, t), this.container.find(".calentim-prev").off(r).one(r, e), this.container.find(".calentim-day").off(r).on(r, i), this.container.find(".calentim-day").off("mouseover.calentim").on("mouseover.calentim", n), this.container.find(".calentim-disabled").not(".calentim-day").off(r), this.container.find(".calentim-range").off(r).on(r, s), this.container.find(".calentim-month-switch ").off(r).on(r, a), this.container.find(".calentim-year-switch ").off(r).on(r, o), !0 === this.globals.isMobile && 1 == this.config.enableSwipe)
                if ("function" == typeof v.fn.swiperight) this.input.find(".calentim-calendars").css("touch-action", "none"), this.input.find(".calentim-calendars").on("swipeleft", t), this.input.find(".calentim-calendars").on("swiperight", e);
                else {
                    var l = new Hammer(this.input.find(".calentim-calendars").get(0));
                    l.off("swipeleft").on("swipeleft", t), l.off("swiperight").on("swiperight", e)
                }!this.globals.isMobile && !this.config.showButtons || this.config.inline || (this.input.find(".calentim-cancel").off("click.calentim").on("click.calentim", v.proxy(function (t) {
                1 == this.config.onCancel(this, this.config.startDate, this.config.endDate) && (this.config.startDate = this.globals.startDateInitial ? this.globals.startDateInitial.clone() : null, this.config.endDate = this.globals.endDateInitial ? this.globals.endDateInitial.clone() : null, this.config.startEmpty && !this.globals.startDateInitial && this.clearInput(), this.updateTimePickerDisplay(), this.updateInput(!1, !1), this.hideDropdown(t))
            }, this)), this.input.find(".calentim-apply").off("click.calentim").on("click.calentim", v.proxy(function (t) {
                this.config.startDate = this.config.startDate || moment(), this.config.endDate = this.config.endDate || moment(), !0 === this.config.onbeforeselect(this, this.config.startDate.clone(), this.config.endDate.clone()) && !0 === this.checkRangeContinuity() ? (this.globals.firstValueSelected = !0, this.globals.delayInputUpdate ? (this.globals.delayInputUpdate = !1, this.updateInput(!0, !1), this.clearRangeSelection(), this.globals.delayInputUpdate = !0) : this.updateInput(!0, !1)) : this.fetchInputs(), this.hideDropdown(t)
            }, this)))
        },
        addInitialEvents: function () {
            var e = this,
                t = "click.calentim";
            this.globals.documentEvent = t + "_" + Math.round((new Date).getTime() + 100 * Math.random()), v(r).on(this.globals.documentEvent, v.proxy(function (t) {
                if (!1 === this.globals.isMobile && !1 === this.config.inline) {
                    var e = t || o.event || jQuery.Event("click", {
                            target: "body"
                        }),
                        i = e.target || e.srcElement;
                    0 === v(this.container).find(v(i)).length && this.elem !== i && 0 < this.container.is(":visible") && this.hideDropdown(e)
                }
            }, this)), this.config.enableKeyboard && (t = "click.calentim focus.calentim"), this.$elem.off(t).on(t, v.proxy(this.debounce(function (t) {
                var e = t || o.event || jQuery.Event("click", {
                        target: "body"
                    }),
                    i = e.target || e.srcElement;
                0 < this.input.get(0).clientHeight && this.config.target.get(0) !== i ? this.hideDropdown(e) : (v(r).trigger("click"), this.showDropdown(e))
            }, 200, !0), this)), this.globals.isMobile && v(o).on("resize.calentim", v.proxy(function (t) {
                this.container.trigger("calentim:resize")
            }, this)), this.container.on("calentim:resize", v.proxy(function () {
                this.globals.rafID = this.requestAnimFrame(function () {
                    if (e.config.showCalendars) {
                        var t = e.input.find(".calentim-calendar:visible:first").innerHeight();
                        e.input.removeClass("calentim-input-top-reset"), e.input.position().top < 0 && e.input.addClass("calentim-input-top-reset"), v(o).width() > v(o).height() ? (e.input.find(".calentim-calendars").css({
                            maxHeight: 99999,
                            minHeight: t
                        }), "flex" === e.input.css("display") && (0 < e.input.find(".calentim-header:visible").length ? e.input.css("height", t + e.input.find(".calentim-header").outerHeight() + 2 + "px") : e.input.css("height", t + 2 + "px"))) : (e.input.css("height", "auto"), e.input.find(".calentim-calendars").css({
                            maxHeight: t,
                            minHeight: 0
                        }))
                    } else e.input.css("height", "auto");
                    e.updateTimePickerDisplay(), e.cancelAnimFrame(e.globals.rafID)
                })
            }, this)), "none" !== this.input.css("display") && this.globals.isMobile && this.container.trigger("calentim:resize"), !1 === this.globals.isMobile && v(o).on("resize.calentim scroll.calentim", function () {
                e.globals.isTicking || (e.globals.isTicking = !0, e.globals.lastScrollX = o.scrollX || o.pageXOffset || r.documentElement.scrollLeft, e.globals.lastScrollY = o.scrollY || o.pageYOffset || r.documentElement.scrollTop, e.globals.rafID = e.requestAnimFrame(v.proxy(function () {
                    this.setViewport(), this.globals.isTicking = !1, this.cancelAnimFrame(this.globals.rafID)
                }, e)))
            })
        },
        stopBubbling: function (t) {
            return "function" == typeof t.stopPropagation ? t.stopPropagation() : void 0 !== t.cancelBubble && (t.cancelBubble = !0), "function" == typeof t.preventDefault && t.preventDefault(), t.returnValue = !1
        },
        debounce: function (n, s, a) {
            return function () {
                var t = this,
                    e = arguments,
                    i = a && !t.globals.throttleTimeout;
                clearTimeout(t.globals.throttleTimeout), t.globals.throttleTimeout = setTimeout(function () {
                    t.globals.throttleTimeout = null, a || n.apply(t, e)
                }, s), i && n.apply(t, e)
            }
        },
        requestAnimFrame: function (t) {
            return "function" == typeof o.requestAnimationFrame ? requestAnimationFrame(t) : "function" == typeof o.webkitRequestAnimationFrame ? webkitRequestAnimationFrame(t) : "function" == typeof o.mozRequestAnimationFrame ? mozRequestAnimationFrame(t) : setTimeout(t, 100 / 6)
        },
        cancelAnimFrame: function (t) {
            return "function" == typeof o.cancelAnimationFrame ? cancelAnimationFrame(t) : "function" == typeof o.webkitCancelAnimationFrame ? webkitCancelAnimationFrame(t) : "function" == typeof o.mozCancelAnimationFrame ? mozCancelAnimationFrame(t) : clearTimeout(t)
        },
        addKeyboardEvents: function () {
            if (this.config.enableKeyboard && this.config.showCalendars) {
                var t = v.proxy(function (t) {
                    var e = t.which ? t.which : t.keyCode;
                    null === this.globals.keyboardHoverDate ? null === this.config.startDate ? this.globals.keyboardHoverDate = moment({
                        day: 1,
                        month: this.calendars.first().data("month")
                    }).middleOfDay() : this.globals.keyboardHoverDate = this.config.startDate.clone().middleOfDay() : this.globals.keyboardHoverDate.middleOfDay();
                    var i = !1,
                        n = !1;
                    switch (e) {
                        case 37:
                            this.globals.keyboardHoverDate.add(-1, "day"), n = i = !0;
                            break;
                        case 38:
                            this.globals.keyboardHoverDate.add(-1, "week"), n = i = !0;
                            break;
                        case 39:
                            this.globals.keyboardHoverDate.add(1, "day"), n = i = !0;
                            break;
                        case 40:
                            this.globals.keyboardHoverDate.add(1, "week"), n = i = !0;
                            break;
                        case 32:
                            this.input.find(".calentim-day[data-value='" + this.globals.keyboardHoverDate.middleOfDay().unix() + "']").first().trigger("click.calentim"), n = !(i = !1);
                            break;
                        case 33:
                            t.shiftKey ? this.globals.keyboardHoverDate.add(-1, "years") : this.globals.keyboardHoverDate.add(-1, "months"), n = i = !0;
                            break;
                        case 34:
                            t.shiftKey ? this.globals.keyboardHoverDate.add(1, "years") : this.globals.keyboardHoverDate.add(1, "months"), n = i = !0;
                            break;
                        case 27:
                            this.hideDropdown(t);
                            break;
                        case 36:
                            t.shiftKey && (this.globals.keyboardHoverDate = moment().middleOfDay(), n = i = !0)
                    }
                    if (i || n) return this.globals.keyboardHoverDate = this.globals.keyboardHoverDate.middleOfDay(), (this.globals.keyboardHoverDate.isBefore(moment.unix(this.input.find(".calentim-day:first").attr("data-value")), "minute") || this.globals.keyboardHoverDate.isAfter(moment.unix(this.input.find(".calentim-day:last").attr("data-value")), "minute")) && (this.globals.currentDate = this.globals.keyboardHoverDate.clone().startOfMonth(), this.reDrawCalendars(), i = !1), i && (this.globals.hoverDate = null, this.reDrawCells()), n && this.stopBubbling(t), this.container.find(".calentim-calendars").focus(), !1
                }, this);
                this.$elem.off("keydown.calentim").on("keydown.calentim", v.proxy(function (t) {
                    var e = t.which ? t.which : t.keyCode;
                    return 9 == e && 0 == t.shiftKey && 0 == this.globals.skipTabKeyOnInput ? (this.container.find(".calentim-calendars").focus(), !1) : (9 == e && 0 == t.shiftKey && (this.globals.skipTabKeyOnInput = !1), !0)
                }, this)), this.container.find(".calentim-calendars").off("keydown.calentim").on("keydown.calentim", t), this.timepickers.find(".calentim-timepicker-ampm").off("keydown.calentim").on("keydown.calentim", function (t) {
                    var e = t.which ? t.which : t.keyCode,
                        i = t.target || t.currentTarget,
                        n = v(i).parent().hasClass("calentim-timepicker-end");
                    switch (e) {
                        case 38:
                        case 40:
                            return v(i).children(":not(.calentim-ampm-selected)").click(), !1;
                        case 9:
                            if (n && 0 == t.shiftKey) {
                                var s = v(i).closest(".calentim-container").data("calentim");
                                s && (s.globals.skipTabKeyOnInput = !0, s.hideDropdown(), s.$elem.focus().trigger(v.Event("keydown.calentim", {
                                    keyCode: 9,
                                    which: 9
                                })))
                            }
                    }
                    return !0
                }), this.timepickers.find(".calentim-timepicker-minutes-wrapper").off("keydown.calentim").on("keydown.calentim", function (t) {
                    var e = t.which ? t.which : t.keyCode,
                        i = t.target || t.currentTarget;
                    switch (e) {
                        case 38:
                            return v(i).siblings(".calentim-timepicker-minute-arrows").find(".calentim-timepicker-minutes-up").click(), !1;
                        case 40:
                            return v(i).siblings(".calentim-timepicker-minute-arrows").find(".calentim-timepicker-minutes-down").click(), !1
                    }
                    return !0
                }), this.timepickers.find(".calentim-timepicker-hours-wrapper").off("keydown.calentim").on("keydown.calentim", function (t) {
                    var e = t.which ? t.which : t.keyCode,
                        i = t.target || t.currentTarget;
                    switch (e) {
                        case 38:
                            return v(i).siblings(".calentim-timepicker-hour-arrows").find(".calentim-timepicker-hours-up").click(), !1;
                        case 40:
                            return v(i).siblings(".calentim-timepicker-hour-arrows").find(".calentim-timepicker-hours-down").click(), !1
                    }
                    return !0
                })
            }
        },
        destroy: function () {
            this.config.onBeforeDestroy(this) && (this.config.inline ? (this.input.remove(), this.globals.isMobile ? this.$elem.unwrap(".calentim-container-mobile") : this.$elem.unwrap(".calentim-container"), this.elem.type = "text") : this.container.remove(), v(r).off(this.globals.documentEvent), this.$elem.removeData("calentim"), this.config.ondestroy(this))
        },
        fixDateTime: function (t) {
            return null != t && 0 == moment.isMoment(t) && (t = "string" == typeof t ? moment(t, this.config.format).locale(this.config.locale) : moment(t).locale(this.config.locale)), t
        },
        checkMobile: function () {
            return o.matchMedia("only screen and (max-width: " + this.config.mobileBreakpoint + "px)").matches
        },
        checkTouch: function () {
            var t = " -webkit- -moz- -o- -ms- ".split(" ");
            if ("ontouchstart" in o || o.DocumentTouch && r instanceof DocumentTouch) return !0;
            var e, i = ["(", t.join("touch-enabled),("), "heartz", ")"].join("");
            return e = i, o.matchMedia(e).matches
        },
        setStart: function (t) {
            var e = this.fixDateTime(t);
            !1 === this.isDisabled(e) && moment(e).isValid() && (this.config.startDate = moment(e), this.config.singleDate && (this.config.endDate = moment(e)), this.refreshValues())
        },
        setEnd: function (t) {
            var e = this.fixDateTime(t);
            !1 === this.isDisabled(e) && moment(e).isValid() && (this.config.endDate = moment(e), this.refreshValues())
        },
        setMinDate: function (t) {
            var e = this.fixDateTime(t);
            moment(e).isValid() && (this.config.minDate = moment(e), this.refreshValues())
        },
        setMaxDate: function (t) {
            var e = this.fixDateTime(t);
            moment(e).isValid() && (this.config.maxDate = moment(e), this.refreshValues())
        },
        setDisplayDate: function (t) {
            var e = this.fixDateTime(t);
            moment(e).isValid() && (this.globals.currentDate = moment(e), this.reDrawCalendars())
        },
        refreshValues: function () {
            var t = this.globals.delayInputUpdate;
            this.globals.delayInputUpdate = !1, this.validateDates(), this.updateTimePickerDisplay(), this.updateInput(), this.globals.delayInputUpdate = t, this.reDrawCells()
        }
    }).defaults, v.fn.calentim = function (t) {
        return this.each(function () {
            null == v(this).data("calentim") && new e(this, t).init()
        })
    }, "function" != typeof moment.fn.middleOfDay && (moment.fn.middleOfDay = function () {
        return this.hours(12).minutes(0).seconds(0), this
    }, moment.fn.startOfMonth = function () {
        return this.middleOfDay().date(1), this
    })
}(jQuery, window, document),
    function (a, s, t, d) {
        "use strict";
        var o, r = ["", "webkit", "Moz", "MS", "ms", "o"],
            e = s.createElement("div"),
            i = "function",
            l = Math.round,
            m = Math.abs,
            f = Date.now;

        function c(t, e, i) {
            return setTimeout(b(t, i), e)
        }

        function n(t, e, i) {
            return !!Array.isArray(t) && (h(t, i[e], i), !0)
        }

        function h(t, e, i) {
            var n;
            if (t)
                if (t.forEach) t.forEach(e, i);
                else if (t.length !== d)
                    for (n = 0; n < t.length;) e.call(i, t[n], n, t), n++;
                else
                    for (n in t) t.hasOwnProperty(n) && e.call(i, t[n], n, t)
        }

        function u(n, t, e) {
            var s = "DEPRECATED METHOD: " + t + "\n" + e + " AT \n";
            return function () {
                var t = new Error("get-stack-trace"),
                    e = t && t.stack ? t.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace",
                    i = a.console && (a.console.warn || a.console.log);
                return i && i.call(a.console, s, e), n.apply(this, arguments)
            }
        }
        o = "function" != typeof Object.assign ? function (t) {
            if (t === d || null === t) throw new TypeError("Cannot convert undefined or null to object");
            for (var e = Object(t), i = 1; i < arguments.length; i++) {
                var n = arguments[i];
                if (n !== d && null !== n)
                    for (var s in n) n.hasOwnProperty(s) && (e[s] = n[s])
            }
            return e
        } : Object.assign;
        var p = u(function (t, e, i) {
                for (var n = Object.keys(e), s = 0; s < n.length;)(!i || i && t[n[s]] === d) && (t[n[s]] = e[n[s]]), s++;
                return t
            }, "extend", "Use `assign`."),
            g = u(function (t, e) {
                return p(t, e, !0)
            }, "merge", "Use `assign`.");

        function v(t, e, i) {
            var n, s = e.prototype;
            (n = t.prototype = Object.create(s)).constructor = t, n._super = s, i && o(n, i)
        }

        function b(t, e) {
            return function () {
                return t.apply(e, arguments)
            }
        }

        function y(t, e) {
            return typeof t == i ? t.apply(e && e[0] || d, e) : t
        }

        function D(t, e) {
            return t === d ? e : t
        }

        function k(e, t, i) {
            h(O(t), function (t) {
                e.addEventListener(t, i, !1)
            })
        }

        function w(e, t, i) {
            h(O(t), function (t) {
                e.removeEventListener(t, i, !1)
            })
        }

        function T(t, e) {
            for (; t;) {
                if (t == e) return !0;
                t = t.parentNode
            }
            return !1
        }

        function x(t, e) {
            return -1 < t.indexOf(e)
        }

        function O(t) {
            return t.trim().split(/\s+/g)
        }

        function S(t, e, i) {
            if (t.indexOf && !i) return t.indexOf(e);
            for (var n = 0; n < t.length;) {
                if (i && t[n][i] == e || !i && t[n] === e) return n;
                n++
            }
            return -1
        }

        function C(t) {
            return Array.prototype.slice.call(t, 0)
        }

        function E(t, i, e) {
            for (var n = [], s = [], a = 0; a < t.length;) {
                var o = i ? t[a][i] : t[a];
                S(s, o) < 0 && n.push(t[a]), s[a] = o, a++
            }
            return e && (n = i ? n.sort(function (t, e) {
                return t[i] > e[i]
            }) : n.sort()), n
        }

        function M(t, e) {
            for (var i, n, s = e[0].toUpperCase() + e.slice(1), a = 0; a < r.length;) {
                if ((n = (i = r[a]) ? i + s : e) in t) return n;
                a++
            }
            return d
        }
        var I = 1;

        function A(t) {
            var e = t.ownerDocument || t;
            return e.defaultView || e.parentWindow || a
        }
        var P = "ontouchstart" in a,
            H = M(a, "PointerEvent") !== d,
            B = P && /mobile|tablet|ip(ad|hone|od)|android/i.test(navigator.userAgent),
            L = "touch",
            z = "mouse",
            F = 25,
            R = 1,
            N = 4,
            V = 8,
            Y = 1,
            _ = 2,
            W = 4,
            X = 8,
            U = 16,
            q = _ | W,
            j = X | U,
            $ = q | j,
            K = ["x", "y"],
            G = ["clientX", "clientY"];

        function Q(e, t) {
            var i = this;
            this.manager = e, this.callback = t, this.element = e.element, this.target = e.options.inputTarget, this.domHandler = function (t) {
                y(e.options.enable, [e]) && i.handler(t)
            }, this.init()
        }

        function Z(t, e, i) {
            var n = i.pointers.length,
                s = i.changedPointers.length,
                a = e & R && n - s == 0,
                o = e & (N | V) && n - s == 0;
            i.isFirst = !!a, i.isFinal = !!o, a && (t.session = {}), i.eventType = e,
                function (t, e) {
                    var i = t.session,
                        n = e.pointers,
                        s = n.length;
                    i.firstInput || (i.firstInput = J(e));
                    1 < s && !i.firstMultiple ? i.firstMultiple = J(e) : 1 === s && (i.firstMultiple = !1);
                    var a = i.firstInput,
                        o = i.firstMultiple,
                        r = o ? o.center : a.center,
                        l = e.center = tt(n);
                    e.timeStamp = f(), e.deltaTime = e.timeStamp - a.timeStamp, e.angle = st(r, l), e.distance = nt(r, l),
                        function (t, e) {
                            var i = e.center,
                                n = t.offsetDelta || {},
                                s = t.prevDelta || {},
                                a = t.prevInput || {};
                            e.eventType !== R && a.eventType !== N || (s = t.prevDelta = {
                                x: a.deltaX || 0,
                                y: a.deltaY || 0
                            }, n = t.offsetDelta = {
                                x: i.x,
                                y: i.y
                            });
                            e.deltaX = s.x + (i.x - n.x), e.deltaY = s.y + (i.y - n.y)
                        }(i, e), e.offsetDirection = it(e.deltaX, e.deltaY);
                    var c = et(e.deltaTime, e.deltaX, e.deltaY);
                    e.overallVelocityX = c.x, e.overallVelocityY = c.y, e.overallVelocity = m(c.x) > m(c.y) ? c.x : c.y, e.scale = o ? function (t, e) {
                        return nt(e[0], e[1], G) / nt(t[0], t[1], G)
                    }(o.pointers, n) : 1, e.rotation = o ? function (t, e) {
                        return st(e[1], e[0], G) + st(t[1], t[0], G)
                    }(o.pointers, n) : 0, e.maxPointers = i.prevInput ? e.pointers.length > i.prevInput.maxPointers ? e.pointers.length : i.prevInput.maxPointers : e.pointers.length,
                        function (t, e) {
                            var i, n, s, a, o = t.lastInterval || e,
                                r = e.timeStamp - o.timeStamp;
                            if (e.eventType != V && (F < r || o.velocity === d)) {
                                var l = e.deltaX - o.deltaX,
                                    c = e.deltaY - o.deltaY,
                                    h = et(r, l, c);
                                n = h.x, s = h.y, i = m(h.x) > m(h.y) ? h.x : h.y, a = it(l, c), t.lastInterval = e
                            } else i = o.velocity, n = o.velocityX, s = o.velocityY, a = o.direction;
                            e.velocity = i, e.velocityX = n, e.velocityY = s, e.direction = a
                        }(i, e);
                    var h = t.element;
                    T(e.srcEvent.target, h) && (h = e.srcEvent.target);
                    e.target = h
                }(t, i), t.emit("hammer.input", i), t.recognize(i), t.session.prevInput = i
        }

        function J(t) {
            for (var e = [], i = 0; i < t.pointers.length;) e[i] = {
                clientX: l(t.pointers[i].clientX),
                clientY: l(t.pointers[i].clientY)
            }, i++;
            return {
                timeStamp: f(),
                pointers: e,
                center: tt(e),
                deltaX: t.deltaX,
                deltaY: t.deltaY
            }
        }

        function tt(t) {
            var e = t.length;
            if (1 === e) return {
                x: l(t[0].clientX),
                y: l(t[0].clientY)
            };
            for (var i = 0, n = 0, s = 0; s < e;) i += t[s].clientX, n += t[s].clientY, s++;
            return {
                x: l(i / e),
                y: l(n / e)
            }
        }

        function et(t, e, i) {
            return {
                x: e / t || 0,
                y: i / t || 0
            }
        }

        function it(t, e) {
            return t === e ? Y : m(t) >= m(e) ? t < 0 ? _ : W : e < 0 ? X : U
        }

        function nt(t, e, i) {
            var n = e[(i = i || K)[0]] - t[i[0]],
                s = e[i[1]] - t[i[1]];
            return Math.sqrt(n * n + s * s)
        }

        function st(t, e, i) {
            var n = e[(i = i || K)[0]] - t[i[0]],
                s = e[i[1]] - t[i[1]];
            return 180 * Math.atan2(s, n) / Math.PI
        }
        Q.prototype = {
            handler: function () {},
            init: function () {
                this.evEl && k(this.element, this.evEl, this.domHandler), this.evTarget && k(this.target, this.evTarget, this.domHandler), this.evWin && k(A(this.element), this.evWin, this.domHandler)
            },
            destroy: function () {
                this.evEl && w(this.element, this.evEl, this.domHandler), this.evTarget && w(this.target, this.evTarget, this.domHandler), this.evWin && w(A(this.element), this.evWin, this.domHandler)
            }
        };
        var at = {
                mousedown: R,
                mousemove: 2,
                mouseup: N
            },
            ot = "mousedown",
            rt = "mousemove mouseup";

        function lt() {
            this.evEl = ot, this.evWin = rt, this.pressed = !1, Q.apply(this, arguments)
        }
        v(lt, Q, {
            handler: function (t) {
                var e = at[t.type];
                e & R && 0 === t.button && (this.pressed = !0), 2 & e && 1 !== t.which && (e = N), this.pressed && (e & N && (this.pressed = !1), this.callback(this.manager, e, {
                    pointers: [t],
                    changedPointers: [t],
                    pointerType: z,
                    srcEvent: t
                }))
            }
        });
        var ct = {
                pointerdown: R,
                pointermove: 2,
                pointerup: N,
                pointercancel: V,
                pointerout: V
            },
            ht = {
                2: L,
                3: "pen",
                4: z,
                5: "kinect"
            },
            dt = "pointerdown",
            mt = "pointermove pointerup pointercancel";

        function ft() {
            this.evEl = dt, this.evWin = mt, Q.apply(this, arguments), this.store = this.manager.session.pointerEvents = []
        }
        a.MSPointerEvent && !a.PointerEvent && (dt = "MSPointerDown", mt = "MSPointerMove MSPointerUp MSPointerCancel"), v(ft, Q, {
            handler: function (t) {
                var e = this.store,
                    i = !1,
                    n = t.type.toLowerCase().replace("ms", ""),
                    s = ct[n],
                    a = ht[t.pointerType] || t.pointerType,
                    o = a == L,
                    r = S(e, t.pointerId, "pointerId");
                s & R && (0 === t.button || o) ? r < 0 && (e.push(t), r = e.length - 1) : s & (N | V) && (i = !0), r < 0 || (e[r] = t, this.callback(this.manager, s, {
                    pointers: e,
                    changedPointers: [t],
                    pointerType: a,
                    srcEvent: t
                }), i && e.splice(r, 1))
            }
        });
        var ut = {
            touchstart: R,
            touchmove: 2,
            touchend: N,
            touchcancel: V
        };

        function pt() {
            this.evTarget = "touchstart", this.evWin = "touchstart touchmove touchend touchcancel", this.started = !1, Q.apply(this, arguments)
        }
        v(pt, Q, {
            handler: function (t) {
                var e = ut[t.type];
                if (e === R && (this.started = !0), this.started) {
                    var i = function (t, e) {
                        var i = C(t.touches),
                            n = C(t.changedTouches);
                        e & (N | V) && (i = E(i.concat(n), "identifier", !0));
                        return [i, n]
                    }.call(this, t, e);
                    e & (N | V) && i[0].length - i[1].length == 0 && (this.started = !1), this.callback(this.manager, e, {
                        pointers: i[0],
                        changedPointers: i[1],
                        pointerType: L,
                        srcEvent: t
                    })
                }
            }
        });
        var gt = {
                touchstart: R,
                touchmove: 2,
                touchend: N,
                touchcancel: V
            },
            vt = "touchstart touchmove touchend touchcancel";

        function bt() {
            this.evTarget = vt, this.targetIds = {}, Q.apply(this, arguments)
        }
        v(bt, Q, {
            handler: function (t) {
                var e = gt[t.type],
                    i = function (t, e) {
                        var i = C(t.touches),
                            n = this.targetIds;
                        if (e & (2 | R) && 1 === i.length) return n[i[0].identifier] = !0, [i, i];
                        var s, a, o = C(t.changedTouches),
                            r = [],
                            l = this.target;
                        if (a = i.filter(function (t) {
                            return T(t.target, l)
                        }), e === R)
                            for (s = 0; s < a.length;) n[a[s].identifier] = !0, s++;
                        s = 0;
                        for (; s < o.length;) n[o[s].identifier] && r.push(o[s]), e & (N | V) && delete n[o[s].identifier], s++;
                        return r.length ? [E(a.concat(r), "identifier", !0), r] : void 0
                    }.call(this, t, e);
                i && this.callback(this.manager, e, {
                    pointers: i[0],
                    changedPointers: i[1],
                    pointerType: L,
                    srcEvent: t
                })
            }
        });
        var yt = 2500;

        function Dt() {
            Q.apply(this, arguments);
            var t = b(this.handler, this);
            this.touch = new bt(this.manager, t), this.mouse = new lt(this.manager, t), this.primaryTouch = null, this.lastTouches = []
        }

        function kt(t) {
            var e = t.changedPointers[0];
            if (e.identifier === this.primaryTouch) {
                var i = {
                    x: e.clientX,
                    y: e.clientY
                };
                this.lastTouches.push(i);
                var n = this.lastTouches;
                setTimeout(function () {
                    var t = n.indexOf(i); - 1 < t && n.splice(t, 1)
                }, yt)
            }
        }
        v(Dt, Q, {
            handler: function (t, e, i) {
                var n = i.pointerType == L,
                    s = i.pointerType == z;
                if (!(s && i.sourceCapabilities && i.sourceCapabilities.firesTouchEvents)) {
                    if (n)(function (t, e) {
                        t & R ? (this.primaryTouch = e.changedPointers[0].identifier, kt.call(this, e)) : t & (N | V) && kt.call(this, e)
                    }).call(this, e, i);
                    else if (s && function (t) {
                        for (var e = t.srcEvent.clientX, i = t.srcEvent.clientY, n = 0; n < this.lastTouches.length; n++) {
                            var s = this.lastTouches[n],
                                a = Math.abs(e - s.x),
                                o = Math.abs(i - s.y);
                            if (a <= 25 && o <= 25) return !0
                        }
                        return !1
                    }.call(this, i)) return;
                    this.callback(t, e, i)
                }
            },
            destroy: function () {
                this.touch.destroy(), this.mouse.destroy()
            }
        });
        var wt = M(e.style, "touchAction"),
            Tt = wt !== d,
            xt = "compute",
            Ot = "manipulation",
            St = "none",
            Ct = "pan-x",
            Et = "pan-y",
            Mt = function () {
                if (!Tt) return !1;
                var e = {},
                    i = a.CSS && a.CSS.supports;
                return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function (t) {
                    e[t] = !i || a.CSS.supports("touch-action", t)
                }), e
            }();

        function It(t, e) {
            this.manager = t, this.set(e)
        }
        It.prototype = {
            set: function (t) {
                t == xt && (t = this.compute()), Tt && this.manager.element.style && Mt[t] && (this.manager.element.style[wt] = t), this.actions = t.toLowerCase().trim()
            },
            update: function () {
                this.set(this.manager.options.touchAction)
            },
            compute: function () {
                var e = [];
                return h(this.manager.recognizers, function (t) {
                    y(t.options.enable, [t]) && (e = e.concat(t.getTouchAction()))
                }),
                    function (t) {
                        if (x(t, St)) return St;
                        var e = x(t, Ct),
                            i = x(t, Et);
                        if (e && i) return St;
                        if (e || i) return e ? Ct : Et;
                        if (x(t, Ot)) return Ot;
                        return "auto"
                    }(e.join(" "))
            },
            preventDefaults: function (t) {
                var e = t.srcEvent,
                    i = t.offsetDirection;
                if (this.manager.session.prevented) e.preventDefault();
                else {
                    var n = this.actions,
                        s = x(n, St) && !Mt[St],
                        a = x(n, Et) && !Mt[Et],
                        o = x(n, Ct) && !Mt[Ct];
                    if (s) {
                        var r = 1 === t.pointers.length,
                            l = t.distance < 2,
                            c = t.deltaTime < 250;
                        if (r && l && c) return
                    }
                    if (!o || !a) return s || a && i & q || o && i & j ? this.preventSrc(e) : void 0
                }
            },
            preventSrc: function (t) {
                this.manager.session.prevented = !0, t.preventDefault()
            }
        };
        var At = 1;

        function Pt(t) {
            this.options = o({}, this.defaults, t || {}), this.id = I++, this.manager = null, this.options.enable = D(this.options.enable, !0), this.state = At, this.simultaneous = {}, this.requireFail = []
        }

        function Ht(t) {
            return 16 & t ? "cancel" : 8 & t ? "end" : 4 & t ? "move" : 2 & t ? "start" : ""
        }

        function Bt(t) {
            return t == U ? "down" : t == X ? "up" : t == _ ? "left" : t == W ? "right" : ""
        }

        function Lt(t, e) {
            var i = e.manager;
            return i ? i.get(t) : t
        }

        function zt() {
            Pt.apply(this, arguments)
        }

        function Ft() {
            zt.apply(this, arguments), this.pX = null, this.pY = null
        }

        function Rt() {
            zt.apply(this, arguments)
        }

        function Nt() {
            Pt.apply(this, arguments), this._timer = null, this._input = null
        }

        function Vt() {
            zt.apply(this, arguments)
        }

        function Yt() {
            zt.apply(this, arguments)
        }

        function _t() {
            Pt.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0
        }

        function Wt(t, e) {
            return (e = e || {}).recognizers = D(e.recognizers, Wt.defaults.preset), new Xt(t, e)
        }
        Pt.prototype = {
            defaults: {},
            set: function (t) {
                return o(this.options, t), this.manager && this.manager.touchAction.update(), this
            },
            recognizeWith: function (t) {
                if (n(t, "recognizeWith", this)) return this;
                var e = this.simultaneous;
                return e[(t = Lt(t, this)).id] || (e[t.id] = t).recognizeWith(this), this
            },
            dropRecognizeWith: function (t) {
                return n(t, "dropRecognizeWith", this) || (t = Lt(t, this), delete this.simultaneous[t.id]), this
            },
            requireFailure: function (t) {
                if (n(t, "requireFailure", this)) return this;
                var e = this.requireFail;
                return -1 === S(e, t = Lt(t, this)) && (e.push(t), t.requireFailure(this)), this
            },
            dropRequireFailure: function (t) {
                if (n(t, "dropRequireFailure", this)) return this;
                t = Lt(t, this);
                var e = S(this.requireFail, t);
                return -1 < e && this.requireFail.splice(e, 1), this
            },
            hasRequireFailures: function () {
                return 0 < this.requireFail.length
            },
            canRecognizeWith: function (t) {
                return !!this.simultaneous[t.id]
            },
            emit: function (e) {
                var i = this,
                    t = this.state;

                function n(t) {
                    i.manager.emit(t, e)
                }
                t < 8 && n(i.options.event + Ht(t)), n(i.options.event), e.additionalEvent && n(e.additionalEvent), 8 <= t && n(i.options.event + Ht(t))
            },
            tryEmit: function (t) {
                if (this.canEmit()) return this.emit(t);
                this.state = 32
            },
            canEmit: function () {
                for (var t = 0; t < this.requireFail.length;) {
                    if (!(this.requireFail[t].state & (32 | At))) return !1;
                    t++
                }
                return !0
            },
            recognize: function (t) {
                var e = o({}, t);
                if (!y(this.options.enable, [this, e])) return this.reset(), void(this.state = 32);
                56 & this.state && (this.state = At), this.state = this.process(e), 30 & this.state && this.tryEmit(e)
            },
            process: function (t) {},
            getTouchAction: function () {},
            reset: function () {}
        }, v(zt, Pt, {
            defaults: {
                pointers: 1
            },
            attrTest: function (t) {
                var e = this.options.pointers;
                return 0 === e || t.pointers.length === e
            },
            process: function (t) {
                var e = this.state,
                    i = t.eventType,
                    n = 6 & e,
                    s = this.attrTest(t);
                return n && (i & V || !s) ? 16 | e : n || s ? i & N ? 8 | e : 2 & e ? 4 | e : 2 : 32
            }
        }), v(Ft, zt, {
            defaults: {
                event: "pan",
                threshold: 10,
                pointers: 1,
                direction: $
            },
            getTouchAction: function () {
                var t = this.options.direction,
                    e = [];
                return t & q && e.push(Et), t & j && e.push(Ct), e
            },
            directionTest: function (t) {
                var e = this.options,
                    i = !0,
                    n = t.distance,
                    s = t.direction,
                    a = t.deltaX,
                    o = t.deltaY;
                return s & e.direction || (n = e.direction & q ? (s = 0 === a ? Y : a < 0 ? _ : W, i = a != this.pX, Math.abs(t.deltaX)) : (s = 0 === o ? Y : o < 0 ? X : U, i = o != this.pY, Math.abs(t.deltaY))), t.direction = s, i && n > e.threshold && s & e.direction
            },
            attrTest: function (t) {
                return zt.prototype.attrTest.call(this, t) && (2 & this.state || !(2 & this.state) && this.directionTest(t))
            },
            emit: function (t) {
                this.pX = t.deltaX, this.pY = t.deltaY;
                var e = Bt(t.direction);
                e && (t.additionalEvent = this.options.event + e), this._super.emit.call(this, t)
            }
        }), v(Rt, zt, {
            defaults: {
                event: "pinch",
                threshold: 0,
                pointers: 2
            },
            getTouchAction: function () {
                return [St]
            },
            attrTest: function (t) {
                return this._super.attrTest.call(this, t) && (Math.abs(t.scale - 1) > this.options.threshold || 2 & this.state)
            },
            emit: function (t) {
                if (1 !== t.scale) {
                    var e = t.scale < 1 ? "in" : "out";
                    t.additionalEvent = this.options.event + e
                }
                this._super.emit.call(this, t)
            }
        }), v(Nt, Pt, {
            defaults: {
                event: "press",
                pointers: 1,
                time: 251,
                threshold: 9
            },
            getTouchAction: function () {
                return ["auto"]
            },
            process: function (t) {
                var e = this.options,
                    i = t.pointers.length === e.pointers,
                    n = t.distance < e.threshold,
                    s = t.deltaTime > e.time;
                if (this._input = t, !n || !i || t.eventType & (N | V) && !s) this.reset();
                else if (t.eventType & R) this.reset(), this._timer = c(function () {
                    this.state = 8, this.tryEmit()
                }, e.time, this);
                else if (t.eventType & N) return 8;
                return 32
            },
            reset: function () {
                clearTimeout(this._timer)
            },
            emit: function (t) {
                8 === this.state && (t && t.eventType & N ? this.manager.emit(this.options.event + "up", t) : (this._input.timeStamp = f(), this.manager.emit(this.options.event, this._input)))
            }
        }), v(Vt, zt, {
            defaults: {
                event: "rotate",
                threshold: 0,
                pointers: 2
            },
            getTouchAction: function () {
                return [St]
            },
            attrTest: function (t) {
                return this._super.attrTest.call(this, t) && (Math.abs(t.rotation) > this.options.threshold || 2 & this.state)
            }
        }), v(Yt, zt, {
            defaults: {
                event: "swipe",
                threshold: 10,
                velocity: .3,
                direction: q | j,
                pointers: 1
            },
            getTouchAction: function () {
                return Ft.prototype.getTouchAction.call(this)
            },
            attrTest: function (t) {
                var e, i = this.options.direction;
                return i & (q | j) ? e = t.overallVelocity : i & q ? e = t.overallVelocityX : i & j && (e = t.overallVelocityY), this._super.attrTest.call(this, t) && i & t.offsetDirection && t.distance > this.options.threshold && t.maxPointers == this.options.pointers && m(e) > this.options.velocity && t.eventType & N
            },
            emit: function (t) {
                var e = Bt(t.offsetDirection);
                e && this.manager.emit(this.options.event + e, t), this.manager.emit(this.options.event, t)
            }
        }), v(_t, Pt, {
            defaults: {
                event: "tap",
                pointers: 1,
                taps: 1,
                interval: 300,
                time: 250,
                threshold: 9,
                posThreshold: 10
            },
            getTouchAction: function () {
                return [Ot]
            },
            process: function (t) {
                var e = this.options,
                    i = t.pointers.length === e.pointers,
                    n = t.distance < e.threshold,
                    s = t.deltaTime < e.time;
                if (this.reset(), t.eventType & R && 0 === this.count) return this.failTimeout();
                if (n && s && i) {
                    if (t.eventType != N) return this.failTimeout();
                    var a = !this.pTime || t.timeStamp - this.pTime < e.interval,
                        o = !this.pCenter || nt(this.pCenter, t.center) < e.posThreshold;
                    if (this.pTime = t.timeStamp, this.pCenter = t.center, o && a ? this.count += 1 : this.count = 1, this._input = t, 0 == this.count % e.taps) return this.hasRequireFailures() ? (this._timer = c(function () {
                        this.state = 8, this.tryEmit()
                    }, e.interval, this), 2) : 8
                }
                return 32
            },
            failTimeout: function () {
                return this._timer = c(function () {
                    this.state = 32
                }, this.options.interval, this), 32
            },
            reset: function () {
                clearTimeout(this._timer)
            },
            emit: function () {
                8 == this.state && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input))
            }
        }), Wt.VERSION = "2.0.8", Wt.defaults = {
            domEvents: !1,
            touchAction: xt,
            enable: !0,
            inputTarget: null,
            inputClass: null,
            preset: [
                [Vt, {
                    enable: !1
                }],
                [Rt, {
                    enable: !1
                },
                    ["rotate"]
                ],
                [Yt, {
                    direction: q
                }],
                [Ft, {
                    direction: q
                },
                    ["swipe"]
                ],
                [_t],
                [_t, {
                    event: "doubletap",
                    taps: 2
                },
                    ["tap"]
                ],
                [Nt]
            ],
            cssProps: {
                userSelect: "none",
                touchSelect: "none",
                touchCallout: "none",
                contentZooming: "none",
                userDrag: "none",
                tapHighlightColor: "rgba(0,0,0,0)"
            }
        };

        function Xt(t, e) {
            this.options = o({}, Wt.defaults, e || {}), this.options.inputTarget = this.options.inputTarget || t, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = t, this.input = function (t) {
                var e = t.options.inputClass;
                return new(e || (H ? ft : B ? bt : P ? Dt : lt))(t, Z)
            }(this), this.touchAction = new It(this, this.options.touchAction), Ut(this, !0), h(this.options.recognizers, function (t) {
                var e = this.add(new t[0](t[1]));
                t[2] && e.recognizeWith(t[2]), t[3] && e.requireFailure(t[3])
            }, this)
        }

        function Ut(i, n) {
            var s, a = i.element;
            a.style && (h(i.options.cssProps, function (t, e) {
                s = M(a.style, e), n ? (i.oldCssProps[s] = a.style[s], a.style[s] = t) : a.style[s] = i.oldCssProps[s] || ""
            }), n || (i.oldCssProps = {}))
        }
        Xt.prototype = {
            set: function (t) {
                return o(this.options, t), t.touchAction && this.touchAction.update(), t.inputTarget && (this.input.destroy(), this.input.target = t.inputTarget, this.input.init()), this
            },
            stop: function (t) {
                this.session.stopped = t ? 2 : 1
            },
            recognize: function (t) {
                var e = this.session;
                if (!e.stopped) {
                    var i;
                    this.touchAction.preventDefaults(t);
                    var n = this.recognizers,
                        s = e.curRecognizer;
                    (!s || s && 8 & s.state) && (s = e.curRecognizer = null);
                    for (var a = 0; a < n.length;) i = n[a], 2 === e.stopped || s && i != s && !i.canRecognizeWith(s) ? i.reset() : i.recognize(t), !s && 14 & i.state && (s = e.curRecognizer = i), a++
                }
            },
            get: function (t) {
                if (t instanceof Pt) return t;
                for (var e = this.recognizers, i = 0; i < e.length; i++)
                    if (e[i].options.event == t) return e[i];
                return null
            },
            add: function (t) {
                if (n(t, "add", this)) return this;
                var e = this.get(t.options.event);
                return e && this.remove(e), this.recognizers.push(t), (t.manager = this).touchAction.update(), t
            },
            remove: function (t) {
                if (n(t, "remove", this)) return this;
                if (t = this.get(t)) {
                    var e = this.recognizers,
                        i = S(e, t); - 1 !== i && (e.splice(i, 1), this.touchAction.update())
                }
                return this
            },
            on: function (t, e) {
                if (t !== d && e !== d) {
                    var i = this.handlers;
                    return h(O(t), function (t) {
                        i[t] = i[t] || [], i[t].push(e)
                    }), this
                }
            },
            off: function (t, e) {
                if (t !== d) {
                    var i = this.handlers;
                    return h(O(t), function (t) {
                        e ? i[t] && i[t].splice(S(i[t], e), 1) : delete i[t]
                    }), this
                }
            },
            emit: function (t, e) {
                this.options.domEvents && function (t, e) {
                    var i = s.createEvent("Event");
                    i.initEvent(t, !0, !0), (i.gesture = e).target.dispatchEvent(i)
                }(t, e);
                var i = this.handlers[t] && this.handlers[t].slice();
                if (i && i.length) {
                    e.type = t, e.preventDefault = function () {
                        e.srcEvent.preventDefault()
                    };
                    for (var n = 0; n < i.length;) i[n](e), n++
                }
            },
            destroy: function () {
                this.element && Ut(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null
            }
        }, o(Wt, {
            INPUT_START: R,
            INPUT_MOVE: 2,
            INPUT_END: N,
            INPUT_CANCEL: V,
            STATE_POSSIBLE: At,
            STATE_BEGAN: 2,
            STATE_CHANGED: 4,
            STATE_ENDED: 8,
            STATE_RECOGNIZED: 8,
            STATE_CANCELLED: 16,
            STATE_FAILED: 32,
            DIRECTION_NONE: Y,
            DIRECTION_LEFT: _,
            DIRECTION_RIGHT: W,
            DIRECTION_UP: X,
            DIRECTION_DOWN: U,
            DIRECTION_HORIZONTAL: q,
            DIRECTION_VERTICAL: j,
            DIRECTION_ALL: $,
            Manager: Xt,
            Input: Q,
            TouchAction: It,
            TouchInput: bt,
            MouseInput: lt,
            PointerEventInput: ft,
            TouchMouseInput: Dt,
            SingleTouchInput: pt,
            Recognizer: Pt,
            AttrRecognizer: zt,
            Tap: _t,
            Pan: Ft,
            Swipe: Yt,
            Pinch: Rt,
            Rotate: Vt,
            Press: Nt,
            on: k,
            off: w,
            each: h,
            merge: g,
            extend: p,
            assign: o,
            inherit: v,
            bindFn: b,
            prefixed: M
        }), (void 0 !== a ? a : "undefined" != typeof self ? self : {}).Hammer = Wt, "function" == typeof define && define.amd ? define(function () {
            return Wt
        }) : "undefined" != typeof module && module.exports ? module.exports = Wt : a.Hammer = Wt
    }(window, document);
//# sourceMappingURL=calentim.min.js.map
